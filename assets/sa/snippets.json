{
  "1.0": {
    "0x40FDD0": "int pVector1 = get_label_pointer @cvector1\nint pVector2 = get_label_pointer @cvector2\nint pVector3 = get_label_pointer @cvector3\n\nCVector_ctor(pVector1, 10.0, 20.0, 30.0)\nCVector_ctor(pVector2, 15.0, 25.0, 35.0)\nCVector_Add(pVector3, pVector1, pVector2)\n\nfloat x = read_memory_with_offset pVector3 0 4\nfloat y = read_memory_with_offset pVector3 4 4\nfloat z = read_memory_with_offset pVector3 8 4\n\nprint_help_formatted \"vec (%.2f, %.2f, %.2f)\" x y z\n\njump @skip\n\nconst sizeOf_CVector = 12\n:cvector1\nhex\n00(sizeOf_CVector)\nend\n:cvector2\nhex\n00(sizeOf_CVector)\nend\n:cvector3\nhex\n00(sizeOf_CVector)\nend\n\n:skip",
    "0x4207A0": "float result1 = aSin(0.5)\nfloat result2 = aSin(-0.7)\nprint_formatted_now {format} \"%f %f\" {time} 1000 {args} result1 result2 // prints \"0.523598775598 -0.775397496611\"",
    "0x43A0B0": "int pCheatCar = CCheat_VehicleCheat(#NRG500)\nCar hCheatCar = get_vehicle_ref {address} pCheatCar\nBlip hCarBlip = add_blip_for_car {vehicle} hCheatCar",
    "0x43F4B0": "int pos[3]  \nint posPtr = get_var_pointer pos\n\nwhile true\n    wait 250\n    \n    pos[0], pos[1], pos[2] = get_char_coordinates $scplayer\n    \n    int idx = CEntryExitManager_FindNearestEntryExit(posPtr, 5.0, -1)\n    print_formatted_now {format} \"EnEx: %d\" {time} 250 {args} idx\nend",
    "0x43FA00": "if is_game_first_start  // enex will persist when reloading\nthen \n    int EnexIndex = CEntryExitManager_AddOne(2459.5, -1691.6, 12.5, 0.0, 1.0, 1.0, 8, 2459.5, -1689.5, 12.5, 0.0, 0, 4, 0, 0, 24, 0, 'RYDERS')\n    if EnexIndex == 0\n    then print_help_formatted \"~r~Error: No room in pool for added enex.\"\n    else print_help_formatted \"Index %d\" EnexIndex\n    end\nend",
    "0x444300": "while true\n    wait 0\n    if test_cheat \"i\"\n    then\n        wait 0\n        if or\n            is_gang_war_going_on\n            is_gang_war_fighting_going_on\n        then\n            CGangWars_EndGangWar(true)\n            Blip hDefenseBlip = read_memory 0x96AB98 size 4 virtual_protect 0  // CGangWars__RadarBlip\n            if does_blip_exist hDefenseBlip\n            then remove_blip hDefenseBlip\n            end    \n        else\n            CGangWars_StartDefensiveGangWar()    \n        end\n    end\nend",
    "0x446050": "while true\n    wait 0\n    if test_cheat \"o\"\n    then\n        wait 0\n        if or\n            is_gang_war_going_on\n            is_gang_war_fighting_going_on\n        then\n            CGangWars_EndGangWar(true)\n            Blip hDefenseBlip = read_memory 0x96AB98 size 4 virtual_protect 0  // CGangWars__RadarBlip\n            if does_blip_exist hDefenseBlip\n            then remove_blip hDefenseBlip\n            end    \n        else\n            CGangWars_StartOffensiveGangWar()    \n        end\n    end\nend",
    "0x4464C0": "CGangWars_EndGangWar(true)\nBlip hDefenseBlip = read_memory 0x96AB98 size 4 virtual_protect 0\nif does_blip_exist hDefenseBlip\nthen remove_blip hDefenseBlip\nend",
    "0x448900": "const cleo_player = 0\n\nwhile true\n    wait 200\n    if is_player_playing cleo_player\n    then \n        int pos = FindPlayerCentreOfWorld(cleo_player)\n        int bInGarage = CGarages_IsPointWithinHideOutGarage(pos)\n        if is_bit_set bInGarage {bitIndex} 0\n        then \n            add_score cleo_player {money} 1\n        end\n    end\nend",
    "0x4563A0": "int pos = FindPlayerCentreOfWorld(-1)\nCPickups_RemoveUnnecessaryPickups(pos, 100.0)\nprint_help_string {text} \"Pickups cleared\"",
    "0x470740": "int DealerIndex = CStreamedScripts_FindStreamedScript(0xA47B60, 'DEALER')\nprint_help_formatted \"Index of streamed DEALER script: %d\" DealerIndex",
    "0x504F80": "int playerChar = get_player_char 0\nint charPtr = get_ped_pointer playerChar\nint weaponAudioPtr = charPtr + 0x394\nconst weaponType = 22 // Pistol\nCAEWeaponAudioEntity_WeaponFire(weaponAudioPtr, weaponType, charPtr, 145)",
    "0x5096F0": "float val = tan(0.78539) // 45 degrees (PI/4)",
    "0x5625F0": "const cleo_player = 0\nint cleo_char = get_player_char cleo_player\nfloat posX, posY, posZ\n\nwhile true\n    wait 0\n    if\n        test_cheat \"p\"\n    then\n        posX, posY, posZ = get_char_coordinates cleo_char\n        int numPolice = CWanted_WorkOutPolicePresence(posX, posY, posZ, 14.0) \n        print_help_formatted \"Number of police in range: %d\" numPolice\n    end\nend",
    "0x5693F0": "spawn_vehicle_by_cheating #INFERNUS\n\nint pos = FindPlayerCentreOfWorld(-1)\nint addr = CWorld_FindNearestObjectOfType(#INFERNUS, pos, 50.0, false, false, {vehicles} true, false, false, false)\n\nif addr > 0\nthen\n    Car infernus = get_vehicle_ref addr\n    Blip b = add_blip_for_car infernus\nelse\n    print_help_formatted \"Car not found\"\nend",
    "0x569660": "Char player_char = get_player_char 0\n\nwhile true\n    wait 0\n    \n    float x, y, _\n    x, y, _ = get_char_coordinates player_char\n\n    float z = CWorld_FindGroundZForCoord(x, y)\n    use_text_commands true\n    display_text_formatted 10.0 0 \"Z coord: %.2f\" z \n    \nend // while",
    "0x56BA00": "// inputs\nfloat fromCoord[3], toCoord[3]\nfromCoord[0] = 1023.0\nfromCoord[1] = 218.13\nfromCoord[2] = 40.0\ntoCoord[0] = 1015.0\ntoCoord[1] = 220.13\ntoCoord[2] = 30.0\n\n// outputs\nfloat out_CollisionPoint[3]\nint out_CollidedEntity\n\nint fromCoordPtr = get_var_pointer fromCoord\nint toCoordPtr = get_var_pointer toCoord\nint collisionPointPtr = get_var_pointer out_CollisionPoint\nint collidedEntityPtr = get_var_pointer out_CollidedEntity\n\nint isCollidingSomething = CWorld_ProcessLineOfSight(fromCoordPtr, toCoordPtr, collisionPointPtr, collidedEntityPtr, isBuilding, isVehicle, isPed, isObject, isParticle, ignoreSeeThroughStuff, ignoreSomeObjectsForCamera, ignoreShootThroughStuff)\nif isCollidingSomething == true\nthen print_formatted_now {format} \"Obstacle detected between two points:~n~Entity: %p~n~%f %f %f\" {time} 1000 {args} out_CollidedEntity ...out_CollisionPoint\nend",
    "0x56E010": "while true\n    wait 0\n    int pVector = get_label_pointer @pos_vec\n    int pPosVector = FindPlayerCoors(pVector, -1)\n    PrintVector(pPosVector) // pVector and pPosVector point to the same memory\nend\n\n:pos_vec\nhex\n00(12)\nend\n\nfunction PrintVector(vec: int {CVector})\n    float x = Memory.ReadWithOffset(vec, 0, 4)\n    float y = Memory.ReadWithOffset(vec, 4, 4)\n    float z = Memory.ReadWithOffset(vec, 8, 4)\n\n    use_text_commands true\n    display_text_formatted 0 0 \"x: %.2f y: %.2f z: %.2f\" x y z\nend",
    "0x56E0D0": "while true\n    wait 0\n    int vehicle = FindPlayerVehicle(-1, false)\n\n    use_text_commands true\n    display_text_formatted 0 0 \"vehicle: %d\" vehicle\nend",
    "0x56E250": "while true\n    wait 0\n    int pos = FindPlayerCentreOfWorld(-1)\n    PrintVector(pos)\nend\n\nfunction PrintVector(vec: int {CVector})\n    float x = Memory.ReadWithOffset(vec, 0, 4)\n    float y = Memory.ReadWithOffset(vec, 4, 4)\n    float z = Memory.ReadWithOffset(vec, 8, 4)\n\n    use_text_commands true\n    set_text_wrapx 640.0\n    display_text_formatted 0 0 \"x: %.2f y: %.2f z: %.2f\" x y z\nend",
    "0x619040": "int s_PcSaveHelper = 0xC17034\nconst slot = 0 // first save slot\n\n// change default save directory\nint save_path = allocate_memory 256\nresolve_filepath {path} \"user:\\\\new_save_dir\" save_path\nfs.CreateDirectory(save_path)\nC_PcSave_SetSaveDirectory(save_path)\nfree_memory {address} save_path",
    "0x619060": "int s_PcSaveHelper = 0xC17034\nconst slot = 0 // first save slot\ndebug_on\n\n// create save\nint res = C_PcSave_SaveSlot(s_PcSaveHelper, slot)\nif res == 2\nthen\n    trace \"save failed\"\nelse\n    trace \"save success\"\nend",
    "0x6190A0": "int save_filename = allocate_memory 256\nint s_PcSaveHelper = 0xC17034\nconst slot = 0 // first save slot\n\nC_PcSave_GenerateGameFilename(s_PcSaveHelper, slot, save_filename)\n\ndebug_on\ntrace \"save filename: %s\" save_filename\nfree_memory save_filename",
    "0x6190D0": "int s_PcSaveHelper = 0xC17034\nconst slot = 0 // first save slot\ndebug_on\n\n// delete save file\nif C_PcSave_DeleteSlot(s_PcSaveHelper, slot)\nthen\n    trace \"save deleted\"\nelse\n    trace \"failed to delete the save\"\nend",
    "0x69FBD0": "int loadedMissionText = allocate_memory {size} 20\nCText_GetNameOfLoadedMissionText(loadedMissionText)\nprint_formatted_now {format} \"loaded Mission: %s\" {time} 5000 {args} loadedMissionText\nfree_memory {address} loadedMissionText",
    "0x6A0050": "int gxtText = CText_Get(0xC1B340, 'CRED007') // Get gxt text address by gxt name\nprint_formatted_now {format} \"%s\" {time} 100 {args} gxtText",
    "0x6D2370": "const modelId = #COPCARLA\nint vehicle = CCheat_VehicleCheat(modelId)\nint res = CVehicle_IsLawEnforcementVehicle(vehicle)\nif is_bit_set res 0\nthen\n    print_formatted \"%d is law enforcement\" 5000 modelId\nelse\n    print_formatted \"%d is not law enforcement\" 5000 modelId\nend\n",
    "0x6E3290": "const UPGRADE_MODEL = #WHEEL_LR1\nrequest_model UPGRADE_MODEL\nload_all_models_now\n\nint pCheatCar = CCheat_VehicleCheat(#MTBIKE)\nif \n    pCheatCar <> 0\nthen \n    CVehicle_AddVehicleUpgrade(pCheatCar, UPGRADE_MODEL)\nelse\n    print_help_formatted \"~r~Vehicle cannot be spawned by cheat at this location.\"\nend",
    "0x6E61B0": "float float fromCoord[3], toCoord[3],\n// do something to fromCoord and toCoord\n\nfloat colPoint[3]\nint colPointPtr = get_var_pointer colPoint\nint isWaterDetected = CWaterManager_TestLineAgainstWater(...fromCoord, ...toCoord, colPointPtr)\nif isWaterDetected\nthen print_formatted_now {format} \"Water Detected at~n~%f %f %f\" {time} 1000 {args} ...colPoint\nend\n",
    "0x6F3240": "CarGenerator hJeffersonNRG = create_car_generator 2243.75 -1258.5 24.0 {heading} 90.0 {modelId} #NRG500 {Colors} 86 86 {forceSpawn} True {alarm} 0 {doorLock} 0 {minDelay} 0 {maxDelay} 10000 // Jefferson Alley\nswitch_car_generator hJeffersonNRG {amount} 101\nint pCargen = CCarGenerator_Get(hJeffersonNRG)\nwrite_memory_with_offset {address} pCargen {offset} 0x1C {size} 1 {value} 0xFE // won't save\nwait 1000\nCTheCarGenerators_RemoveCarGenerators(0xFE)",
    "0x6FDEA0": "Player p = 0\nChar playerChar = p.GetChar()\n\nwhile true\n    wait 0\n    if \n        playerChar.IsInAnyCar()\n    then\n        int vehicle = playerChar.StoreCarIsInNoSave()\n        int pVehicle = Memory.GetVehiclePointer(vehicle)\n        \n        int hours, minutes \n        hours, minutes = Clock.GetTimeOfDay()\n        longstring plateText\n        string_format plateText \" %d %d \" hours minutes\n        updateCarPlateText(pVehicle, plateText)\n    end    \nend // while\n\n\nfunction updateCarPlateText(pVehicle: int, plateText: string)\n    unloadCarPlateTexture(pVehicle)\n    int plateTexture = CCustomCarPlateMgr_CreatePlateTexture(plateText, -1)\n    write_memory_with_offset {address} pVehicle {offset} 0x588 {size} 4 {value} plateTexture\nend\n\nfunction unloadCarPlateTexture(pVehicle: int)    \n    int pCustomCarPlate = read_memory_with_offset {address} pVehicle {offset} 0x588 {size} 4\n    if is_truthy pCustomCarPlate\n    then\n        RwTextureDestroy(pCustomCarPlate)\n    end\nend",
    "0x706F60": "while true\n    wait 0\n    \n    if\n        test_cheat {input} \"1\"\n    then\n        float pos[3]\n        int posPtr = get_var_pointer pos\n        int texPtr\n        \n        pos[0], pos[1], pos[2] = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 0.0 -0.5\n        //texPtr = read_memory {address} 0x00C403E0 {size} 4 {vp} false // gpShadowCarTex\n        texPtr = read_memory {address} 0x00C403E4 {size} 4 {vp} false // gpShadowPedTex\n        CShadows_AddPermanentShadow(1, texPtr, posPtr, 0.5, 0, 0, -0.5, 200, 0, 0, 0, 10.0, 5000, 1.0)\n        \n        pos[0], pos[1], pos[2] = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 6.0 -0.5\n        texPtr = read_memory {address} 0x00C403FC {size} 4 {vp} false // gpShadowHeadLightsTex2\n        CShadows_AddPermanentShadow(2, texPtr, posPtr, 4.0, 0, 0, -4.0, 255, 0, 128, 255, 10.0, 3000, 1.0)\n    end\nend",
    "0x70CE30": "float worldCoords[3], screenCoords[3], unknown1, unknown2\nint worldCoordsPtr = get_var_pointer worldCoords\nint screenCoordsPtr = get_var_pointer screenCoords\nint unknown1Ptr = get_var_pointer unknown1\nint unknown2Ptr = get_var_pointer unknown2\n\nworldCoords[0] = 1000.0\nworldCoords[1] = 274.0\nworldCoords[2] = 10.0\nint result = CSprite_CalcScreenCoords(worldCoordsPtr, screenCoordsPtr, unknown1Ptr, unknown2Ptr, false, false)\nif result <> 0\nthen print_formatted_now {format} \"coords found at:~n~%f %f~n~Depth: %f\" {time} 1000 {args} ...screenCoords\nend",
    "0x71DAB0": "float worldCoords[3], screenCoords[3]\nint worldCoordsPtr = get_var_pointer worldCoords\nint screenCoordsPtr = get_var_pointer screenCoords\n\n...wordCoords = get_char_coordinates $scplayer\nint result = CalcScreenCoords(worldCoordsPtr, screenCoordsPtr\nif result <> 0\nthen print_formatted_now {format} \"coords found at:~n~%f %f~n~Depth: %f\" {time} 1000 {args} ...screenCoords\nend",
    "0x73A3E0": "int modelIdx = get_weapontype_model {weapon_type} WeaponType.Ak47\nrequest_model {modelId} modelIdx\nload_all_models_now\ngive_weapon_to_char $scplayer {weaponType} WeaponType.Ak47 {ammo} 999999\nmark_model_as_no_longer_needed {modelId} modelIdx\n\nwhile true\n    wait 50\n    \n    WEAPON_ADD_SHELL($scplayer, 7) \nend\n\nfunction WEAPON_ADD_SHELL(charHandle :int, weaponSlot :int)\n    float pos[3]\n    pos[0], pos[1], pos[2] = get_offset_from_char_in_world_coords charHandle {offset} 0.0 1.0 1.0\n\n    float dir[2]\n    dir[0] = 1.0\n    dir[1] = 0.0\n    \n    int posPtr = get_var_pointer pos\n    int dirPtr = get_var_pointer dir\n    \n    int pedPtr = get_ped_pointer {char} charHandle\n\n    int weaponPtr = pedPtr + 0x5A0 // CPed.m_aWeapons[]\n    weaponSlot *= 0x1C // size of CWeapon\n    weaponPtr += weaponSlot\n        \n    CWeapon_AddGunshell(weaponPtr, pedPtr, posPtr, dirPtr, 5.0)\nend\n",
    "0x766575": "float result1 = aCos(-0.46)\nfloat result2 = aCos(0.7)\nprint_formatted_now {format} \"%f %f\" {time} 1000 {args} result1 result2 // prints \"2.048791525314 0.795398830184\"",
    "0x766581": "float val1 = aTan2(-15.0, 13.0)\nprint_formatted_now {format} \"atan2 result: %frads\" {time} 1000 {args} val1 // prints \"atan2 result: -0.856705628183rads\"\n",
    "0x82258E": "while true\n    wait 0\n    Text.UseCommands(true)\n    int i = atoi('42')\n    Text.DisplayFormatted(100.0, 100.0, \"%d\", i)\nend",
    "0x822650": "while true\n    wait 0\n    Text.UseCommands(true)\n    int s = strstr('Test String', 'Str')\n    Text.DisplayFormatted(100.0, 100.0, s)\nend\n",
    "0x823CEE": "while true\n    wait 0\n    Text.UseCommands(true)\n    float f = atof('10.5')\n    Text.DisplayFormatted(100.0, 100.0, \"%.1f\", f)\nend"
  },
  "CLEO": {
    "0A8E": "<%= output1 %> = <%= input1 %> + <%= input2 %>",
    "0A8F": "<%= output1 %> = <%= input1 %> - <%= input2 %>",
    "0A90": "<%= output1 %> = <%= input1 %> * <%= input2 %>",
    "0A91": "<%= output1 %> = <%= input1 %> / <%= input2 %>",
    "0A92": "stream_custom_script {scriptFileName} \"./otherScript.s\" {args} 42 3.1415",
    "0A94": "load_and_launch_custom_mission \"my_mission\" // starts cleo\\my_mission.cm file\n\n// wait for mission script to end\nrepeat\n    wait 250\nuntil $onmission == false",
    "0AA2": "int iTmp\nif and\n    not iTmp = load_dynamic_library {fileName} \"SilentPatchIII.asi\"\n    not iTmp = load_dynamic_library {fileName} \"SilentPatchVC.asi\"\n    not iTmp = load_dynamic_library {fileName} \"SilentPatchSA.asi\"\nthen\n    print_help_formatted \"SilentPatch not detected!\"\nend",
    "0AA4": "int libCleo\nif\n    not libCleo = load_dynamic_library \"CLEO.asi\"\nthen\n    print_help_formatted {text} \"~r~ERROR:~s~ Failed to load CLEO.asi\"\n    terminate_this_script\nend\n\n\n// approach 1\nint procAddr\nif \n    not procAddr = get_dynamic_library_procedure \"_CLEO_GetVersion@0\" {library} libCleo\nthen\n    print_help_formatted {text} \"~r~ERROR:~s~ Failed to get CLEO_GetVersion procedure\"\n    terminate_this_script\nend\n\nint ver = call_function_return procAddr {params} 0 {pop} 0\nprint_help_formatted {text} \"CLEO version is %X\" ver\n\n\nwait 3000\n\n\n// approach 2 - use Sanny Builder 4 foreign functions syntax\nfunction Export_Arg_0_Ret<stdcall>() : int // define function type\nExport_Arg_0_Ret CLEO_GetGameDirectory // variable\nif\n    not CLEO_GetGameDirectory = get_dynamic_library_procedure \"_CLEO_GetGameDirectory@0\" {library} libCleo\nthen\n    print_help_formatted {text} \"~r~ERROR:~s~ Failed to get CLEO_GetGameDirectory procedure\"\n    terminate_this_script\nend\n\nint dir = CLEO_GetGameDirectory()\nprint_help_formatted {text} \"Game directory is: %s\" dir",
    "0AB0": "while true\n    wait 0\n\n    if\n        is_key_pressed {keyCode} KeyCode.F8\n    then\n        print_help_formatted {text} \"~r~Key pressed!\"\n\n        // wait for key release\n        while is_key_pressed {keyCode} KeyCode.F8\n            wait 0\n        end\n        \n        print_help_formatted {text} \"~g~Key released!\"\n    end\nend",
    "0AB1": "while true\n    wait 250\n    \n    if and\n        is_player_playing $player1\n        test_cheat \"gun\"\n    then\n        int ammo = GIVE_PLAYER_WEAPON(38) // this is actually CLEO_CALL command\n        print_help_formatted {text} \"%d bullets!\" {args} ammo\n    end\nend\n\nfunction GIVE_PLAYER_WEAPON(weaponType :int) : int\n    int modelIdx = get_weapontype_model {weapon_type} weaponType\n    request_model {modelId} modelIdx\n    load_all_models_now\n    \n    give_weapon_to_char $scplayer {weaponType} weaponType {ammo} 100\n    \n    mark_model_as_no_longer_needed {modelId} modelIdx\n    \n    // check and return ammo count\n    int ammo = get_ammo_in_char_weapon $scplayer {weaponType} weaponType\n    cleo_return 1 ammo\nend",
    "0AB5": "debug_on\nint blipPed = -1\nint blipVeh = -1\nwhile true\n    wait 0\n    \n    if\n        test_cheat {input} \"5\"\n    then\n        if\n            blipPed <> -1\n        then\n            remove_blip blipPed\n            blipPed = -1\n        end\n        if\n            blipVeh <> -1\n        then\n            remove_blip blipVeh\n            blipVeh = -1\n        end\n    \n        int pedHandle, vehHandle\n        vehHandle, pedHandle = store_closest_entities $scplayer\n\n        trace \"store_closest_entities -> ped: %p, veh: %p\" pedHandle vehHandle\n\n        if\n            pedHandle <> -1\n        then\n            blipPed = add_blip_for_char {char} pedHandle\n        end\n        if\n            vehHandle <> -1\n        then\n            blipVeh = add_blip_for_car {char} vehHandle\n        end       \n    end\nend",
    "0AB6": "debug_on // enable \"trace\" command\nwhile true\n    wait 500\n    \n    float x, y, z\n    if\n        x, y, z = get_target_blip_coords\n    then\n        trace \"get_target_blip_coords -> %.1f %.1f %.1f\" x y z\n    else\n        trace \"get_target_blip_coords -> false\"\n    end \nend",
    "0ACC": "print_string {text} \"Hello from ~y~CLEO~s~!\" {time} 5000",
    "0AD1": "while true\n    wait 0\n    \n    char playerChar = get_player_char 0 // player 1\n    \n    float x, y, z\n    x, y, z = get_char_coordinates playerChar\n    \n    int worldIdx = get_char_area_visible playerChar\n    \n    print_formatted_now {format} \"Position: %0.1f %0.1f %0.1f ~n~ Interior: %d\" {time} 50 {args} x y z worldIdx\nend",
    "0AD2": "debug_on // enable \"trace\" command\nint blipHandle = -1\nwhile true\n    wait 200\n    \n    if\n        blipHandle <> -1\n    then\n        remove_blip blipHandle\n        blipHandle = -1\n    end\n\n    if\n        int pedHandle = get_char_player_is_targeting $player1\n    then\n        blipHandle = add_blip_for_char {char} pedHandle\n        trace \"get_char_player_is_targeting -> %p, true\" pedHandle\n    else\n        trace \"get_char_player_is_targeting -> %p, false\" pedHandle\n    end\nend",
    "0AD3": "int buff = allocate_memory {size} 64\nstring_format {result} buff {format} \"%d + %d = %d\" {args} 2 2 4",
    "0AD7": "debug_on // enable trace command\n\nif\n    int fileaHandle = open_file {filePathName} \"root:\\cleo.log\" {mode} \"rt\"\nthen\n    int buffer = allocate_memory {size} 64\n    if\n        read_string_from_file fileaHandle {storeTo} buffer {maxLength} 64\n    then\n        trace \"Read data: %s\" buffer\n    else\n        trace \"Failed to read data\"\n    end\n    \n    // cleanup\n    free_memory {address} buffer\n    close_file fileaHandle\nelse\n    trace \"Failed to open the file\"\nend",
    "0AD9": "write_formatted_string_to_file outputFile {format} \"Timer is %d.%c\" {args} TimerA 0x0A // end of line",
    "0ADC": "while true\n    wait 0\n    \n    if \n        test_cheat \"TEST\"\n    then\n        print_help_string {text} \"Cheat activated\"\n    end\nend",
    "0ADD": "while true\n    wait 100\n    \n    if\n        test_cheat {input} \"car\"\n    then\n        int modelIdx = generate_random_int_in_range {min} 400 {max} 600\n        print_help_formatted {text} \"Car model: %d\" {args} modelIdx\n        \n        spawn_vehicle_by_cheating {modelId} modelIdx\n    end\nend",
    "0AE1": "while true\n    wait 100\n    \n    if\n        test_cheat \"1\"\n    then\n        float x, y, z\n        x, y, z = get_active_camera_coordinates\n        \n        int ped = get_random_char_in_sphere_no_save_recursive {pos} x y z {radius} 30.0 {find_next} false {filter} CharSearchFilter.AnyAliveNPC // get first\n        while ped <> -1\n            explode_char_head ped\n            \n            ped = get_random_char_in_sphere_no_save_recursive {pos} x y z {radius} 30.0 {find_next} true {filter} CharSearchFilter.AnyAliveNPC // get next\n        end\n    end\nend",
    "0AE2": "while true\n    wait {time} 100\n\n    float x, y, z\n    x, y, z = get_active_camera_coordinates\n    \n    int color = generate_random_int_in_range {min} 0 {max} 9\n    \n    // iterate near cars\n    int handle = get_random_car_in_sphere_no_save_recursive {pos} x y z {radius} 40.0 {findNext} false {skipWrecked} true // initialize search, get first\n    while handle <> -1 // found!\n        change_car_colour handle {color1} color {color2} color\n        \n        handle = get_random_car_in_sphere_no_save_recursive {pos} x y z {radius} 40.0 {findNext} true {skipWrecked} true // get next\n    end\nend",
    "0AE3": "while true\n    wait {time} 0 // once every render frame\n\n    float x, y, z\n    x, y, z = get_active_camera_coordinates\n        \n    // iterate near objects\n    int handle = get_random_object_in_sphere_no_save_recursive {pos} x y z {radius} 30.0 {findNext} false // initialize search, get first\n    while handle <> -1 // found!\n        DRAW_OBJECT_INFO(handle) // call function for every found object\n\n        handle = get_random_object_in_sphere_no_save_recursive {pos} x y z {radius} 30.0 {findNext} true // get next\n    end\nend\n\n\n// display text at 3d coordinates\nfunction DRAW_OBJECT_INFO(obj :int)\n    int modelIdx = get_object_model obj\n\n    float pos[3]\n    pos[0], pos[1], pos[2] = get_object_coordinates obj\n\n    float screenPos[2]\n    float screenSize[2]\n    screenPos[0], screenPos[1], screenSize[0], screenSize[1] = convert_3d_to_screen_2d {pos} pos[0] pos[1] pos[2] {nearClip} true {farClip} true\n    \n    use_text_commands {state} true\n    \n    // calculate our font proportions\n    screenSize[0] = screenSize[1]\n    screenSize[0] *= 0.3 \n    set_text_scale {widthScale} screenSize[0] {heightScale} screenSize[1]\n    \n    set_text_centre {state} true\n    \n    set_text_colour {rgb} 255 255 0 {alpha} 255\n    set_text_edge {size} 1 {RGBA} 0 0 0 64\n    \n    display_text_formatted {offsetLeft} screenPos[0] {offsetTop} screenPos[1] {format} \"%d\" {args} modelIdx\nend",
    "0DD5": "get_platform 0@\nprint_help_formatted \"Platform is %d\" 0@",
    "2000": ":my_funct\n    get_cleo_arg_count 31@\n    print_formatted_now \"called with %d arguments\" {time} 3000 {args} 31@\ncleo_return",
    "2002": "cleo_return_with true retArgs 0@",
    "2003": "int carHandle = -1\nif\n    carHandle = GET_PLAYER_CAR()\nthen\n    // success\nelse\n    // failed\n    // carHandle is -1 (not modified)\nend\n\n// ...\n\nterminate_this_script\n\n// ...\n\n// get player's current vehicle handle\nfunction GET_PLAYER_CAR(): int\n    if\n        not is_char_sitting_in_any_car $scplayer\n    then\n        cleo_return_fail\n    end\n\n    int handle = store_car_char_is_in_no_save $scplayer\n    cleo_return_with true {args} handle\nend"
  },
  "CLEO+": {
    "0E1D": "while true\n    wait {time} 0\n    if\n        is_key_just_pressed {keyCode} KeyCode.F11\n    then\n        if\n            is_on_mission\n        then\n            set_on_mission false\n        else\n            set_on_mission true\n        end\n    end\nend",
    "0E2A": "{$USE CLEO+}\n\nCleoBlip ogLocBlip = add_cleo_blip {rwTextureOrRadarSprite} 28 {x} 2486.0 {y} -1650.0 {short} false {red} 64 {green} 255 {blue} 128 {alpha} 255\n\nload_texture_dictionary 'LD_TATT' // in models\\txd\\\nload_sprite 1 \"5cross2\" // Rose\nint roseTXD = get_texture_from_sprite {spriteSlot} 1\nCleoBlip bRose = add_cleo_blip {rwTexture} roseTXD {pos} 2598.5 -1650.0 {short} True {rgba} 255 0 0 255\n\nload_sprite 2 \"4spider\"\nint spiderTXD = get_texture_from_sprite {spriteSlot} 2\nwrite_memory 0xB4E690 4 spiderTXD False // CVehicleModelInfo::ms_pLightsOnTexture\nCleoBlip bSpider = add_cleo_blip {RadarSprite} -2 {pos} 2598.5 -1750.0 {short} True {rgba} 0 0 255 255 // use the sprite index but negative\nremove_texture_dictionary\n\n{$USE newOpcodes}\nif\n    int myTXD = load_texture_from_png_file {png} \"CLEO\\myImage.png\"\nthen\n    CleoBlip bBlip = add_cleo_blip {rwTexture} myTXD {pos} 2598.5 -1850.0 {short} True {rgba} 255 255 255 255\nend",
    "0E33": "int temp_handle\nif\n    not temp_handle = get_pickup_this_coord {x} 2468.9 {y} -1789.0 {z} 13.4 {onlyValid} true\nthen\n    temp_handle = Pickup.CreateWithAmmo(#M4, PickupType.OnStreetSlow, 500, 2468.9, -1789.0, 13.4)\nend",
    "0E3D": "const Key_F11=122\nwhile true\n    wait 0\n    if is_key_just_pressed Key_F11\n    then\n        if is_on_mission\n        then set_on_mission False\n        else set_on_mission True\n        end\n    end\nend",
    "0E3F": "while true\n    wait 0\n    \n    float pos[3]\n    pos[0], pos[1], pos[2] = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 0.0 1.0 // above head\n    \n    float screenPos[2]\n    float screenSize[2]\n    screenPos[0], screenPos[1], screenSize[0], screenSize[1] = convert_3d_to_screen_2d {pos} pos[0] pos[1] pos[2] {nearClip} true {farClip} true\n    \n    use_text_commands {state} true\n    \n    // calculate our font proportions\n    screenSize[0] = screenSize[1]\n    screenSize[0] *= 0.3 \n    set_text_scale {widthScale} screenSize[0] {heightScale} screenSize[1]\n    \n    set_text_edge {size} 1 {RGBA} 0 0 0 255\n    set_text_centre {state} true\n    display_text_formatted {offsetLeft} screenPos[0] {offsetTop} screenPos[1] {format} \"Player\"\nend",
    "0E4E": "{$USE CLEO+}\n\nint screenTimer\ndisplay_onscreen_timer_local {var_timer} screenTimer {direction} TimerDirection.Down\nscreenTimer = 10000 // 10 seconds\nset_timer_beep_countdown_time_local {var_timer} screenTimer {timeInSec} 6 // start beeping when less than 6 seconds left\n\nwhile true\n    wait 0\n    \n    print_formatted_now {text} \"Peek time left: %d\" {time} 3000 {args} screenTimer\n    \n    if\n        screenTimer == 0\n    then\n        print_string_now {text} \"Time is up!\" {time} 3000\n        break // exit the loop\n    end    \nend\n\nclear_onscreen_timer_local {var_timer} screenTimer",
    "0E4F": "{$USE CLEO+}\n\nadd_text_label {dynamicKey} 'TMR_TXT' {text} \"~r~Explosion\"\n\nint screenTimer\ndisplay_onscreen_timer_with_string_local {var_timer} screenTimer {direction} TimerDirection.Down {text} 'TMR_TXT'\nscreenTimer = 10000 // 10 seconds\nset_timer_beep_countdown_time_local {var_timer} screenTimer {timeInSec} 6 // start beeping when less than 6 seconds left\n\nwhile true\n    wait 0\n\n    print_formatted_now {text} \"Peek time left: %d\" {time} 100 {args} screenTimer\n\n    if\n        screenTimer == 0\n    then\n        print_string_now {text} \"~r~BOOM!\" {time} 3000\n        break // exit the loop\n    end\nend\n\nclear_onscreen_timer_local {var_timer} screenTimer",
    "0E5F": "const player=0\nint char, car\nfloat x,y,z\n\nget_player_char player store_to char\nrepeat\n    print_formatted \"Find a car to honk.\" 1000\n    wait 1000\nuntil is_char_in_any_car char\n\nstore_car_char_is_in_no_save char store_to car\ntimera = 0\nrepeat\n    wait 0\n    car_horn car\nuntil timera > 5000",
    "0E60": "set_camera_control false\nprint_help_formatted \"Camera control is OFF\"\nwait 10000\nset_camera_control true\nprint_help_formatted \"Camera control is ON\"",
    "0E83": "const player=0\nint char, weaponInfo, flags\nget_player_char player store_to char\n\nget_current_char_weaponinfo char store_to weaponInfo\nget_weaponinfo_flags weaponInfo store_to flags\nprint_help_formatted \"WeaponInfo Flags %.5X\" flags",
    "0E84": "const Pistol=22, Std=1\nint weaponInfo, totalClip\n\nget_weaponinfo Pistol skill Std store_to weaponInfo\nget_weaponinfo_total_clip weaponInfo store_to totalClip\nprint_help_formatted \"Total Clip %d\" totalClip",
    "0E85": "const player=0\nint char, weaponInfo, model1, model2\nget_player_char player store_to char\n\nget_current_char_weaponinfo char store_to weaponInfo\nget_weaponinfo_models weaponInfo store_to model1 model2\nprint_help_formatted \"Weapon Models~n~%d~n~%d\" model1 model2",
    "0E86": "const player=0\nint char, weaponInfo, flags\nget_player_char player store_to char\n\nget_current_char_weaponinfo char store_to weaponInfo\nget_weaponinfo_flags weaponInfo store_to flags\nprint_help_formatted \"WeaponInfo Flags %.5X\" flags",
    "0E87": "const player=0\nint char, weaponInfo, animGroup\nget_player_char player store_to char\n\nget_current_char_weaponinfo char store_to weaponInfo\nget_weaponinfo_animgroup weaponInfo store_to animGroup\nprint_help_formatted \"AnimGroup %d\" animGroup",
    "0E88": "const Pistol=22, Std=1\nint weaponInfo, totalClip\n\nget_weaponinfo Pistol skill Std store_to weaponInfo\nget_weaponinfo_total_clip weaponInfo store_to totalClip\nprint_help_formatted \"Total Clip %d\" totalClip",
    "0E89": "const player=0\nint char, weaponInfo, fireType\nget_player_char player store_to char\n\nget_current_char_weaponinfo char store_to weaponInfo\nget_weaponinfo_fire_type weaponInfo store_to fireType\nprint_help_formatted \"FireType %d\" fireType",
    "0E8A": "const player=0\nint char, weaponInfo, slot\nget_player_char player store_to char\n\nget_current_char_weaponinfo char store_to weaponInfo\nget_weaponinfo_slot weaponInfo store_to slot\nprint_help_formatted \"Weapon Slot %d\" slot",
    "0E8B": "const player=0\nint char, weaponState\nget_player_char player store_to char\n\nget_char_weapon_state char store_to weaponState\nprint_help_formatted \"Weapon State %d\" weaponState",
    "0E8C": "const player=0\nint char, weaponClip\nget_player_char player store_to char\n\nget_char_weapon_clip char store_to weaponClip\nprint_help_formatted \"Weapon Clip %d\" weaponClip",
    "0E8D": "const player=0\nrepeat\n    wait 0\nuntil is_any_fire_button_pressed pad player\nprint_help_formatted \"primary or secondary fire button is pressed\"",
    "0E92": "const player = 0\nint char\nget_player_char player store_to char\n\nwhile true\n    wait 0\n    if and\n        not is_char_entering_any_car char\n    \tnot is_char_in_any_car char\n        is_char_really_in_air char                                                       \n    then                                                                                        \n        print_formatted \"Char is REALLY in air\" 2000\n        wait 2000  \n    end\nend",
    "0E93": "const player=0\nint char, car\nget_player_char player store_to char\n\nwhile true\n    wait 0\n    if                                                                          \n        is_char_in_any_car char                                    \n    then                                                                        \n        get_car_char_is_using char store_to car                    \n        if                                                                        \n            is_car_really_in_air car                                           \n        then                                                                      \n            print_formatted \"Car is REALLY in air\" 2000\n            wait 2000  \n        end                                                                       \n    end\nend",
    "0E94": "const player=0, CJ_STEAL_TV=2648 \nint char, object\nfloat x,y,z\n\nget_player_char player store_to char\nget_offset_from_char_in_world_coords char 0.0 2.0 0.0 x y z\ncreate_object_no_save CJ_STEAL_TV at x y z offset false ground false store_to object\nset_object_as_stealable object true\nprint_formatted \"Press ~k~~VEHICLE_ENTER_EXIT~ to pick up the TV\" time 4000\nwait 4000\n\nwhile true\n    wait 0\n    if                                                                    \n        is_object_really_in_air object                                       \n    then                                                                  \n        print_formatted \"Object is REALLY in air\" 2000\n        wait 2000  \n    end                                                \nend",
    "0E9C": "const ModelName = \"NRG500\"\nint MyModel = get_model_by_name {name} ModelName\nprint_help_formatted \"Model ID of %s = %d\" ModelName MyModel \nwait 3000\n\nconst FakeName = \"OMG999\"\nif MyModel = get_model_by_name {name} FakeName\nthen print_help_formatted \"Model ID of %s = %d\" FakeName MyModel\nelse print_help_formatted \"%s is not a valid model name\" FakeName\nend",
    "0E9D": "const ModelName = 'CopGrl1'\nif is_model_available_by_name {name} ModelName\nthen load_special_character {slotId} 1 {modelName} ModelName\nelse print_help_formatted \"%s is not a valid special character model.\" ModelName \nend",
    "0ED5": "{$CLEO .cs}\n{$USE Cleo+}\n\nset_script_event_car_create {add} true EVENT_ON_CAR_CREATE {varCar} 0@\n\n// main script loop\nwhile true\n    wait {time} 1000\nend\n\n\n// event handler\nfunction EVENT_ON_CAR_CREATE(carHandle: int)\n    if\n        is_emergency_services_vehicle carHandle\n    then\n        int blipHandle = add_blip_for_car {vehicle} carHandle\n        change_blip_colour blipHandle {color} BlipColor.Cyan\n    end\n\n    return_script_event\nend",
    "0ED8": "{$CLEO .cs}\n{$USE Cleo+}\n\ndebug_on // enable trace command\n\nset_script_event_on_menu {add} true {callback} EVENT_ON_MENU {varJustPaused} 0@\n\n// main loop\nwhile true\n    wait {time} 1000\n    trace \"main loop\"\nend\n\n\n// event handler\nfunction EVENT_ON_MENU(justPaused: int)\n    trace \"EVENT_ON_MENU: %d\" justPaused\n\n    return_script_event\nend",
    "0F16": "const Key_F11=122\nwhile true\n    wait 0\n    if is_key_just_pressed Key_F11\n    then\n        if is_on_mission\n        then set_on_mission False\n        else set_on_mission True\n        end\n    end\nend"
  },
  "SAMPFUNCS": {
    "0AF6": "SAMP_FORCE_SPAWN_MY_PLAYER",
    "0AF7": "int sampaddr = SAMP_GET_BASE_ADDRESS",
    "0AF8": "SAMP_ADD_MESSAGE_TO_CHAT {format} \"Script Initialized!\" {color} 0xFF00FFFF {args} // shows a literal string as teal colored text\n\nSAMP_ADD_MESSAGE_TO_CHAT {format} \"WeaponID: %d, Weapon Damage: %f, WeaponName:%s\" {color} 0xFF00FFFF {values} 24 14@ \"Desert Eagle\" // shows a formatted string as teal colored text",
    "0AF9": "// Example 1: Sends a String Constant to Server.\nSAMP_SEND_CHAT_MESSAGE \"Hello Everyone!\"\nSAMP_SEND_CHAT_MESSAGE \"/cmds\"\n\n\n// Example 2: Periodically sends a formatted text message to server\n{$CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nrepeat\n    wait 100\nuntil samp_is_available\n\nint loopIndex = 1\n\nwhile true\n    wait 3000\n    int myID = samp_get_player_id $scplayer\n    int myName = samp_get_player_nickname {id} myID\n    samp_send_chat_message {message} \"%d) My Name is %s.\" {args} loopIndex myName\n    loopIndex++\nend\n",
    "0AFA": "if SAMP_IS_AVAILABLE\nthen\n    // gta_sa is running in SAMP\nelse\n    // samp is still loading its structures, or gta_sa is running in single player\nend\n\n\n// samp.dll takes time to initialize its structures, executing samp-related opcodes will lead to gta_sa crash. To avoid this, we must wait indefinitely until samp is fully initialized.\nrepeat\n    wait 100\nuntil SAMP_IS_AVAILABLE\n\n// the rest of the code",
    "0AFB": "int targetClassID\n// do something to targetClassID\nSAMP_SEND_REQUEST_CLASS {id} targetClassID\n\n\nSAMP_SEND_REQUEST_CLASS {classid} 13",
    "0AFC": "int myCarID\n// do something to myCarID\nSAMP_SEND_SCM_EVENT {carid} myCarID {type} SampScmEvent.PaintJob {param1} 2 {param2} 0 // informs the server that myCarID's paintjob changed into style1 = 2, style2 = 0.",
    "0AFD": "SAMP_SET_SPECIAL_ACTION {actionid} SampSpecialAction.UseCellphone",
    "0AFE": "SAMP_SEND_DEATH_BY_PLAYER {playerid} 15 {weaponid} WeaponType.M4 // tells the server I got killed by player 15 using M4 gun\nSAMP_SEND_DEATH_BY_PLAYER {playerid} 0xFFFF {weaponid} WeaponType.Fall // tells the server that I died naturally by falling\n\nint killerID, killerWeapon\n// do something\nSAMP_SEND_DEATH_BY_PLAYER {playerid} killerID {weaponid} killerWeapon",
    "0AFF": "int myCarID\nint myCarHandle = SAMP_GET_CAR_BY_ID {id} myCarID\n// do something to myCarHandle",
    "0B20": "int targetPlayer, targetChar\n// do something to targetPlayer\ntargetChar = samp_get_player_char_by_id {id} targetPlayer\n// do something to targetChar",
    "0B21": "if SAMP_IS_CHAT_INPUT_VISIBLE\nthen // chat input is visible\nelse // chat input is hidden\nend",
    "0B22": "SAMP_SET_SEND_RATE {type} SampSendRateType.Onfoot {delay} 150 // periodically synchronize our onfoot data to server every 50ms\nSAMP_SET_SEND_RATE {type} SampSendRateType.InCar {delay} 200 // periodically synchronize our incar data to server every 200ms\nSAMP_SET_SEND_RATE {type} SampSendRateType.Aims {delay} 50 // periodically synchronize our aim data to server every 50ms",
    "0B23": "if SAMP_IS_REMOTE_PLAYER_CONNECTED {id} 15\nthen\n    // player 15 is connected to server\nelse\n    // player 15 does not exist\nend",
    "0B24": "int playerStruct = SAMP_GET_PLAYER_POINTER {playerid} 15 // get pointer to player 15's struct",
    "0B25": "int targetHealth, targetplayer\n// do something to targetplayer\n{health} targetHealth = SAMP_GET_PLAYER_HEALTH {playerid} targetplayer",
    "0B26": "int targetArmor, targetPlayer\n// do something to targetPlayer\n{armor} targetArmor = SAMP_GET_PLAYER_ARMOR {playerid} targetPlayer",
    "0B27": "SAMP_SET_GAMESTATE {statusid} SampGameState.Disconnected // disconnect to server",
    "0B28": "SAMP_SEND_DISCONNECTED {reasonid} SampDisconnectReason.KickedOrBanned",
    "0B29": "SAMP_SET_MY_NICKNAME {nickname} \"ajom\" // locally change our nickname into ajom\n\n\nint strBuf = ALLOCATE_MEMORY {size} 30\n// write something to strBuf as a valid string\nSAMP_SET_MY_NICKNAME {nickname} strBuf // locally change our nickname into ajom\nFREE_MEMORY {address} strBuf",
    "0B2A": "// get my ping\nint myPlayerID, myPing\nint playerChar = get_player_char 0\n{id} myPlayerID = SAMP_GET_PLAYER_ID {handle} playerChar\n{ping} myPing = SAMP_GET_PLAYER_PING {playerid} myPlayerID",
    "0B2B": "// get my player id\nint char = get_player_char 0\nint myID = SAMP_GET_PLAYER_ID {handle} char",
    "0B2C": "int targetHandle\n// do something to targetHandle\nint targetID = SAMP_GET_CAR_ID {handle} targetHandle",
    "0B2D": "// Example: Take clean screenshot for 0.3.7 R1\n\nSAMP_WRITE_SAMP_MEMORY_WITH_OFFSET {offset} 0x5D8C1 {value} false {size} 1 // temporarily disable SAMP manual screenshot when pressing F8\nwait 500 // give all other scripts time to hide our hacks :)\nSAMP_WRITE_SAMP_MEMORY_WITH_OFFSET {offset} 0x119CBC {value} true {size} 1 // programmatically take SAMP screenshot\nwait 500 // necessary delay to make sure that the screenshot is clean before enabling manual screenshot\nSAMP_WRITE_SAMP_MEMORY_WITH_OFFSET {offset} 0x5D8C1 {value} true {size} 1 // reenable SAMP manual screenshot when pressing F8",
    "0B2E": "bool isManualScreenshotEnabled = SAMP_READ_SAMP_MEMORY_WITH_OFFSET {offset} 0x5D8C1 {size} 1 // for 0.3.7 R1",
    "0B2F": "int targetPlayer\n// do something to targetPlayer\n\n// passing to an array\nfloat targetCoord[3]\n{xyz} targetCoord = SAMP_GET_STREAMED_OUT_PLAYER_COORDS {playerid} targetPlayer\n\n// passing to variables\nfloat targetX, targetY, targetZ\n{x} targetX, {y} targetY, {z} targetZ = SAMP_GET_STREAMED_OUT_PLAYER_COORDS {playerid} targetPlayer",
    "0B30": "///////////////////////////////Example 1///////////////////////////////\n// enter car as driver then inform samp about it.\nint targetCar, targetCarID\n// do something to targetCar\nif DOES_VEHICLE_EXIST {handle} targetCar\nthen\n    TASK_ENTER_CAR_AS_DRIVER {char} $scplayer {vehicle} targetCar {time} 10000\n\n    {id} targetCarID = SAMP_GET_CAR_ID {handle} targetCar\n    SAMP_SEND_ENTER_CAR {carid} targetCarID  {ispassenger} false\n\n    TASK_ENTER_CAR_AS_PASSENGER {char} [Char] {vehicle} [Car] {time} [int] {seat} [SeatId]\nend\n\n///////////////////////////////Example 2///////////////////////////////\n\n// enter car as passenger then inform samp about it.\nint targetCar, targetCarID\n// do something to targetCar\nif DOES_VEHICLE_EXIST {handle} targetCar\nthen\n    TASK_ENTER_CAR_AS_PASSENGER {char} $scplayer {vehicle} targetCar {time} 10000 {seat} 0 // first passenger seat, hijack if necessary\n\n    {id} targetCarID = SAMP_GET_CAR_ID {handle} targetCar\n    SAMP_SEND_ENTER_CAR {carid} targetCarID  {ispassenger} true\nend",
    "0B31": "// Makes our Character exit his current Car and then informs SAMP about it\nint myCar, myCarID\nif IS_CHAR_SITTING_IN_ANY_CAR {Char} $PLAYER_ACTOR\nthen\n    {car} myCar = STORE_CAR_CHAR_IS_IN_NO_SAVE {char} $PLAYER_ACTOR\n    TASK_LEAVE_ANY_CAR {handle} $PLAYER_ACTOR\n    {id} myCarID = SAMP_GET_CAR_ID {handle} myCar\n    SAMP_SEND_EXIT_CAR {carid} myCarID\nend",
    "0B32": "// tells the server that we will spawn without teleporting our character\nSAMP_SEND_SPAWN",
    "0B33": "{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nREPEAT\n    wait 100\nuntil SAMP_IS_AVAILABLE\n\n// Peeling Car Troll Example\nwhile true\n    int myCar, myCarID\n    wait 1000\n    if IS_CHAR_SITTING_IN_ANY_CAR {char} $scplayer\n    then\n        myCar = STORE_CAR_CHAR_IS_IN_NO_SAVE {char} $scplayer\n        myCarID = SAMP_GET_CAR_ID {handle} myCar\n        SAMP_SEND_DAMAGE_CAR {carid} myCarID {bodyflags} 0x00000000 {doorflags} 0x00000000 {lightflags} 0x00 {wheelflags} 0x00 // tells the server that all components of our car are functional\n    end\n    wait 1000\n    if IS_CHAR_SITTING_IN_ANY_CAR {char} $scplayer\n    then\n        myCar = STORE_CAR_CHAR_IS_IN_NO_SAVE {char} $scplayer\n        myCarID = SAMP_GET_CAR_ID {handle} myCar\n        SAMP_SEND_DAMAGE_CAR {carid} myCarID {bodyflags} 0xFFFFFFFF {doorflags} 0xFFFFFFFF {lightflags} 0xFF {wheelflags} 0xFF // tells the server that all components of our car are damaged\n    end\nend",
    "0B34": "// Script Example\n// Type /receiveweapon <weapon id> <ammo> to receive a weapon with ammo\n// Our character will receive SPAZ Gun with 1324 bullets:\n// /receiveweapon 27 1324\n\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nSAMP_HOOK_CHAT_COMMAND_AS_LOCAL {chatcommand} \"receiveweapon\" {callbacklabel} @ChatCallback_ReceiveWeapon\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {streamid} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\n\n:ChatCallback_ReceiveWeapon\n    int cmdParams, paramCountCheck, weaponID, ammo\n    if cmdParams = SF_GET_PARAMS_OF_LAST_TRIGGERED_COMMAND // check if user included parameters after the command keyword\n    then\n        if paramCountCheck, weaponID, ammo = SCAN_STRING {string} cmdParams {format} \"%hhu %u\"\n        then\n            if paramCountCheck == 2 // 2 parameters were parsed\n            then\n                if HAS_CHAR_GOT_WEAPON {char} $scplayer {weaponType} weaponID\n                then ADD_AMMO_TO_CHAR {char} $scplayer {weaponType} weaponID {ammo} ammo\n                else GIVE_WEAPON_TO_CHAR {char} $scplayer {weaponType} weaponID {ammo} ammo\n                end\n            end\n        end\n    end\nSF_COMMAND_RETURN // end of callback",
    "0B35": "/*\n * Check the snippet of the following commands for example usage of this command:\n * SAMP_HOOK_CHAT_COMMAND_AS_LOCAL\n * SF_REGISTER_CONSOLE_COMMAND\n */\nint cmdParams\nif cmdParams = SF_GET_PARAMS_OF_LAST_TRIGGERED_COMMAND\nthen // user provided parameters on its last command\nelse // user provided no parameters on its last command\nend",
    "0B36": "int targetPlayer\n// do something to targetPlayer\nint {nickname} targetNick = SAMP_GET_PLAYER_NICKNAME {playerid} targetPlayer",
    "0B37": "int targetPlayer\n// do something to targetPlayer\nint targetColor = SAMP_GET_PLAYER_COLOR {playerid} targetPlayer",
    "0B38": "SAMP_CONNECT {stringserverip} \"127.0.0.1\" {port} 7777 // connect to our local server using its ip counterpart\n\nwait 10000\n\nSAMP_CONNECT {stringserverip} \"localhost\" {port} 7777 // connect to our local server using its domain name counterpart\n\nwait 10000\n\nSAMP_CONNECT {stringserverip} \"51.79.255.181\" {port} 7778 // connect to a certain remote server by ip\n\nwait 10000\n\nSAMP_CONNECT {stringserverip} \"samp.ugbase.eu\" {port} 7777 // connect to a certain remote server by domain name",
    "0B39": "// Example 1, server ip isn't retrieved if we passing NULL (0) pointer to buffer parameter\nint port\nSAMP_GET_SERVER_ADDRESS {var_buffer} 0 {var_port} port\n// server ip in string format has been written at the allocated memory region strBuf\n// do something to strBuf\nFREE_MEMORY {address} strBuf // free this temporary memory region to avoid memory leak\n\n// Example 2, port isn't retrieved if we pass any constant to port parameter\nint strBuf\nstrBuf = ALLOCATE_MEMORY {size} 16\nSAMP_GET_SERVER_ADDRESS {var_buffer} strBuf {var_port} 324\n// server ip in string format has been written at the allocated memory region strBuf\n// do something to strBuf\nFREE_MEMORY {address} strBuf // free this temporary memory region to avoid memory leak\n\n// Example 3, how to correctly write the server IP to string variable 1@v\nconst\n    port = 0@\n    strBuf = 1@\nend\nstrBuf = GET_VAR_POINTER strBuf // get pointer to self\nstrBuf, port = SAMP_GET_SERVER_ADDRESS\n// server ip in string format has been written to strBuf. This string occupies 16 bytes to satisfy the string ip(uses 1@, 2@, 3@, 4@)\n\n// Example 4, retrieves the port and writes the server IP to a temporarily allocated memory\nint strBuf, port\nstrBuf = ALLOCATE_MEMORY {size} 16\nstrBuf, port = SAMP_GET_SERVER_ADDRESS\n// server ip in string format has been written at the allocated memory region strBuf\n// do something to strBuf and port\nFREE_MEMORY {address} strBuf // free this temporary memory region to avoid memory leak",
    "0B3A": "int strBuf = ALLOCATE_MEMORY {size} 256\nSAMP_GET_SERVER_NAME strBuf\n// do something to {buffer} strBuf\nFREE_MEMORY strBuf",
    "0B3B": "SAMP_SHOW_DIALOG {id} 123 {title} \"Artificial SAMP Dialog\" {content} \"This is its content\" {leftOrMiddleButtonName} \"Cancel\" {rightButtonName} \"Submit\" {style} SampDialogStyle.Msgbox",
    "0B3C": "// Example 1: Simple Dialog Response Check incase we don't need to retrieve any ouputs, we pass a constant NULL (0) to them instead of a variable \nif SAMP_HAS_DIALOG_RESPONDED {dialogid} 117 {buttonidstore} 0  {buttonidstore} 0 {inputtextwritetostringbuffer} 0\nthen // we have responded to dialog 117\nelse // we are still interacting with dialog 117, or dialog 117 still hasn't shown up.\nend\n\n\n// Example 2: Get Pressed Button ID, Selected Item ID, and the Input Text\nint whichButton, whichItem\nint inputtedText = ALLOCATE_MEMORY {size} 300\nif whichButton, whichItem,  inputtedText = SAMP_HAS_DIALOG_RESPONDED {dialogid} 117\nthen // we have responded to dialog 117\n    do something to whichButton, whichItem, and inputtedText\nelse // we are still interacting with dialog 117, or dialog 117 still hasn't shown up.\nend\nFREE_MEMORY {address} inputtedText",
    "0B3D": "int myBitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to myBitStream\nSAMP_RAKNET_DELETE_BITSTREAM myBitStream // free from memory",
    "0B3E": "int myBitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to myBitStream\nSAMP_RAKNET_DELETE_BITSTREAM myBitStream // free from memory",
    "0B3F": "int myBitstream = SAMP_RAKNET_CREATE_BITSTREAM\nSAMP_RAKNET_BITSTREAM_WRITE myBitstream {value} 0x83FF3ABC {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int // example command that increases the Write Pointer by 4\nint testValue = SAMP_RAKNET_BITSTREAM_READ myBitstream {datatype} SampBitStreamDataType.Short {datasize} DataTypeSize.Short // example command that increases the Read Pointer by 2\n// expected: testValue = 0x3ABC\nint checkWriteOffset, checkReadOffset\ncheckWriteOffset = SAMP_RAKNET_BITSTREAM_GET_WRITE_OFFSET myBitstream\ncheckReadOffset = SAMP_RAKNET_BITSTREAM_GET_READ_OFFSET myBitstream\n// expected: checkWriteOffset = 4\n// expected: checkReadOffset = 2\n\nSAMP_RAKNET_RESET_BITSTREAM myBitstream\ncheckWriteOffset = SAMP_RAKNET_BITSTREAM_GET_WRITE_OFFSET myBitstream\ncheckReadOffset = SAMP_RAKNET_BITSTREAM_GET_READ_OFFSET myBitstream\n// expected: checkWriteOffset = 0\n// expected: checkReadOffset = 0",
    "0B40": "/*\n * Check the following commands for example usage of this command:\n * * SAMP_RAKNET_HOOK_OUTCOMING_RPC\n * * SAMP_RAKNET_HOOK_OUTCOMING_PACKET\n * * SAMP_RAKNET_HOOK_INCOMING_RPC\n * * SAMP_RAKNET_HOOK_INCOMING_PACKET\n */\n\nint myBitstream = SAMP_RAKNET_CREATE_BITSTREAM\nSAMP_RAKNET_BITSTREAM_WRITE myBitstream {value} 0x83FF3ABC {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int",
    "0B41": "if IS_CHAR_SITTING_IN_ANY_CAR $scplayer\nthen\n    int myCar = STORE_CAR_CHAR_IS_IN_NO_SAVE $scplayer\n    int myCarID = SAMP_GET_CAR_ID myCar\n        // Construct a Bitstream holding a SampRpc.DamageCar data\n    int myBitStream = SAMP_RAKNET_CREATE_BITSTREAM // create bitstream object with class Bitstream\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} myCarID {datatype} SampBitStreamDataType.Short {datasize} DataTypeSize.Short // CarID\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} 0xFFFFFFFF {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int // bodyflags\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} 0xFFFFFFFF {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int // doorflags\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} 0xFF {datatype} SampBitStreamDataType.Byte {datasize} DataTypeSize.Byte // lightflags\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} 0xFF {datatype} SampBitStreamDataType.Byte {datasize} DataTypeSize.Byte // wheelflags\n        //\n    // Bitstream is ready to be transmitted\n    SAMP_RAKNET_SEND_RPC_WITH_PARAMS {rpcid} SampRpc.DamageCar {bitstream} myBitStream {priorityid} SampPriority.Medium {reliabilityid} SampReliability.ReliableOrdered {orderingchannel} 0 {shifttimestamp} 0\nend",
    "0B42": "int myRCONCommand = ALLOCATE_MEMORY 58\nmyRCONCommand = STRING_FORMAT \"This_is_a_very_long_String_Example_we_will_send\"\nint textLength = SF_STRLEN myRCONCommand\n    // Construct a Bitstream holding a SampRpc.RconCommand data\nint myBitStream = SAMP_RAKNET_CREATE_BITSTREAM // create bitstream object with class Bitstream\nSAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} SampRpc.RconCommand {datatype} SampBitStreamDataType.Byte {datasize} DataTypeSize.Byte // PacketID\nSAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} textLength {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int // TextLength\nSAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} myRCONCommand {datatype} SampBitStreamDataType.Array {datasize} textLength // CMDText\n    //\n// Bitstream is ready to be transmitted\nSAMP_RAKNET_SEND_PACKET_WITH_PARAMS {bitstream} myBitStream {priorityid} SampPriority.Medium {reliabilityid} SampReliability.ReliableOrdered {orderingchannel} 0\nFREE_MEMORY myRCONCommand",
    "0B43": "/*\n * Check the snippet of the following commands for example usage of this command:\n * SAMP_HOOK_CHAT_COMMAND_AS_LOCAL\n * SF_REGISTER_CONSOLE_COMMAND\n */\nSF_COMMAND_RETURN",
    "0B44": "// Example 1: attach a 3D text to our character or car\nint attachedID, my3DTextID\nif IS_CHAR_SITTING_IN_ANY_CAR $scplayer\nthen // attach a red 3d text at the top of my car\n    int myCar = STORE_CAR_CHAR_IS_IN_NO_SAVE $scplayer\n    int myCarModel = GET_CAR_MODEL myCar\n    float offsetZ, unused\n    unused, unused, unused, unused, unused, offsetZ = get_model_dimensions {modelId} myCarModel\n    offsetZ += 2.0 // elevate\n    attachedID = SAMP_GET_CAR_ID {handle} myCar\n    if my3DTextID = SAMP_CREATE_3D_TEXT {text} \"I'm InCar\" {color} 0xFFFF0000 {coordx} 0.0 {coordy} 0.0 {coordz} offsetZ {visibilityradius} 10.0 {showbehindwalls} true {attachedplayerid} -1 {attachedcarid} attachedID\n    then // my3DTextID has been created successfully\n        // do something to my3DTextID\n    end\nelse // attach a purple 3d text at my character's back\n    attachedID = SAMP_GET_PLAYER_ID {handle} $scplayer\n    if my3DTextID = SAMP_CREATE_3D_TEXT {text} \"I'm Onfoot\" {color} 0xFFFF00FF {coordx} 0.0 {coordy} -2.0 {coordz} 0.0 {visibilityradius} 10.0 {showbehindwalls} true {attachedplayerid} attachedID {attachedcarid} -1\n    then // my3DTextID has been created successfully\n        // do something to my3DTextID\n    end\nend\n\n\n// Example 2: Create a yellow 3D Text at specified world coordinate\nint my3DTextID\nif my3DTextID = SAMP_CREATE_3D_TEXT {text} \"Hello World!\" {color} 0xFFFFFF00 {coordx} 1324.14 {coordy} -2032.44 {coordz} 50.13 {visibilityradius} 50.0 {showbehindwalls} false {attachedplayerid} -1 {attachedcarid} -1\nthen // my3DTextID has been created successfully\n    // do something to my3DTextID\nend",
    "0B45": "int target3DTextID\n// do something to target3DTextID\nif SAMP_DELETE_3D_TEXT {3Dtextid} target3DTextID\nthen // target3DTextID is now gone\nelse // target3DTextID doesn't exist\nend",
    "0B46": "if SAMP_DOES_3D_TEXT_EXIST {3Dtextid} 13 // checks if a 3dtext with id = 13 exists\nthen\n    // 3dtext 13 is streamed around somewhere\nelse\n    // 3dtext 13 is not streamed\nend",
    "0B47": "if SAMP_CLOSE_ACTIVE_DIALOG_WITH_BUTTON 0 // Press No Button\nthen // closed the dialog successfully\nelse // dialog is not opened\nend\n\nif SAMP_CLOSE_ACTIVE_DIALOG_WITH_BUTTON 1 // Press Yes Button\nthen // closed the dialog successfully\nelse // dialog is not opened\nend",
    "0B48": "int itemid\nif itemid = SAMP_GET_ACTIVE_DIALOG_SELECTED_LIST_ITEM\nthen // a dialog with list style is currently opened\n    // do something to itemid\nend",
    "0B49": "if SAMP_SELECT_ACTIVE_DIALOG_LIST_ITEM {itemid} 3\nthen\n    // element 3 has been selected\nelse\n    // dialog is either not opened, style is not list, or itemid is invalid\nend",
    "0B4A": "int strbuf = ALLOCATE_MEMORY {size} 300\nif strbuf = SAMP_GET_ACTIVE_DIALOG_EDITBOX_TEXT\nthen\n    // do something to strbuf\nelse\n    // dialog is not opened or is not an edit dialog\nend\nFREE_MEMORY {address} strbuf",
    "0B4B": "if SAMP_SET_ACTIVE_DIALOG_EDITBOX_TEXT \"Sample Text\"\nthen\n    // do something\nelse\n    // dialog is not opened or is not an edit dialog\nend",
    "0B4C": "if SAMP_IS_DIALOG_ACTIVE {dialogid} 183\nthen // dialog 183 is visible\nelse // dialog 183 is not visible\nend",
    "0B4D": "int dialogType\nif dialogType = SAMP_GET_DIALOG_STYLE\nthen // do something\nelse // no dialog has been opened since the beginning of the game\nend",
    "0B4E": "int dialogID\nif dialogID = SAMP_GET_DIALOG_ID\nthen // do something\nelse // no dialog has been opened since the beginning of the game\nend",
    "0B4F": "int connectionStatus = SAMP_GET_GAMESTATE\nswitch connectionStatus\n   case SampGameState.Disconnected\n     // do something when disconnected\n   case SampGameState.Connected\n     // do something when connected\n   case SampGameState.WaitConnect, SampGameState.AwaitJoin, SampGameState.Restarting\n     // do something when establishing connection\n   default\n     // do something when status is unrecognizable\nend",
    "0B50": "int myObject \nif myObject = SAMP_GET_OBJECT_BY_ID {id} 77\nthen // object 77 is streamed\n    // do something to myObject\nelse // object 77 is not streamed\nend",
    "0B51": "int targetPickup\nif targetPickup = SAMP_GET_PICKUP_BY_ID {id} 13\nthen // pickup 13 is streamed\n    // do something to targetPickup\nelse // pickup 13 is not streamed\nend",
    "0B52": "int targetObject, targetObjectID\n// do something to targetObject\nif targetObjectID = SAMP_GET_OBJECT_ID {handle} targetObject\nthen // targetObject is a SAMP Object\n    // do something to targetObjectID\nelse\n    // targetObject is a GTA Local Object(Artificially created at our Client)\nend",
    "0B53": "int targetPickup, targetPickupID\n// do something to targetPickup\nif targetPickupID = SAMP_GET_PICKUP_ID {handle} targetPickup\nthen // targetPickup is a SAMP Pickup\n    // do something to targetPickupID\nelse\n    // targetPickup is a GTA Local Pickup(Artificially created at our Client)\nend",
    "0B54": "int itemsCount\nif itemsCount = SAMP_GET_DIALOG_LIST_ITEMS_COUNT\nthen // do something\nelse\n    // no dialog has been opened since the beginning of the game\n    // or the detected dialog does not have a list attribute\nend",
    "0B55": "int targetActor\nif targetActor = GET_CHAR_PLAYER_IS_TARGETING $player1\nthen\n    int targetScreenX, targetScreenY, myScreenX, myScreenY\n\n    // get target screen coordinates\n    float worldX, worldY, worldZ\n    worldX, worldY, worldZ = GET_CHAR_COORDINATES targetActor\n\n    targetScreenX, targetScreenY = SF_WORLD_COORDS_TO_WINDOW_SCREEN_COORDS {worldcoordx} worldX {worldcoordy} worldY {worldcoordz} worldZ\n\n    // get my screen coordinates\n    worldX, worldY, worldZ = GET_CHAR_COORDINATES $scplayer\n    myScreenX, myScreenY = SF_WORLD_COORDS_TO_WINDOW_SCREEN_COORDS {worldcoordx} worldX {worldcoordy} worldY {worldcoordz} worldZ\n\n    // draw a teal-colored line from me to target\n    SF_D3D_DRAW_LINE {fromcoordx} myScreenX {fromcoordy} myScreenY {tocoordx} targetScreenX {tocoordy} targetScreenY {tickness} 2 {color} 0xFF00FFFF\nend",
    "0B56": "if IS_CHAR_ON_FOOT $scplayer\nthen\n    // sprint leftwards for 1 second\n    TIMERA = 0\n    repeat\n        SF_SET_BUTTON {buttonid} Button.LeftStickX {state} -128 // press run leftwards key\n        SF_SET_BUTTON {buttonid} Button.Cross {state} -128 // press Sprint key\n        wait 0\n    until TIMERA > 1000\n\n    // sprint rightwards for 1 second\n    TIMERA = 0\n    repeat\n        SF_SET_BUTTON {buttonid} Button.LeftStickX {state} 128 // press run rightwards key\n        SF_SET_BUTTON {buttonid} Button.Cross {state} -128 // press Sprint key\n        wait 0\n    until TIMERA > 1000\n\n    // fire weapon for 3 seconds\n    TIMERA = 0\n    repeat\n        SF_SET_BUTTON {buttonid} Button.Circle {state} 255 // press fire key\n        wait 0\n    until TIMERA > 3000\nend",
    "0B57": "int targetAnimID, targetPlayerID\n// do something to targetPlayerID\nif targetAnimID = SAMP_GET_PLAYER_ANIMATION {playerid} targetPlayerID\nthen\n    // do something to targetAnimID\nelse // targetPlayerID's character is not defined\nend",
    "0B58": "int myPlayerID = samp_get_player_id {handle} $scplayer\nint myAnimID = samp_get_player_animation {playerid} myPlayerID\nint strBufFileName = allocate_memory {size} 20\nint strBufAnimName = allocate_memory {size} 20\nstrBufFileName, strBufAnimName = SAMP_GET_ANIMATION_NAME {animid} myAnimID\n\n// do something to strBufFileName and strBufAnimName\n\nif strBufFileName, strBufAnimName = SAMP_GET_ANIMATION_NAME {animid} 8237 // <<<< test invalid id\nthen\n    // this will not be reached\nelse\n    // expected to reach here\nend\n\nFREE_MEMORY {address} strBufFileName\nFREE_MEMORY {address} strBufAnimName",
    "0B59": "int testedAnimID\n\nif testedAnimID = SAMP_GET_ANIMATION_ID {animname} \"ribbit\" {filename} \"frog\" // test invalid animation\nthen\n    // this will not be reached\nelse\n    // this will be reached\nend\n\nif testedAnimID = SAMP_GET_ANIMATION_ID {animname} \"BOMBER\" {filename} \"PED\" // test valid animation\nthen\n    // expected testedAnimID = 1006\n    // do something to testedAnimID\nelse\nend",
    "0B5A": "int screenwidth, screenheight = sf_get_screen_resolution\n// do something to screenwidth and screenheight",
    "0B5B": "int strBufItemText = ALLOCATE_MEMORY {size} 300\nif strBufItemText = SAMP_GET_DIALOG_LIST_ITEM_TEXT {itemid} 3\nthen // opened dialog has itemid 3\n    // do something to strBufItemText\nelse // dialog or itemid 3 not found\nend\nFREE_MEMORY strBufItemText",
    "0B5C": "int testedPlayer\n// do something to testedPlayer\nif SAMP_IS_PLAYER_PAUSED {playerid} testedPlayer\nthen // player is AFK\nelse // player is active\nend",
    "0B5D": "SAMP_SET_CURSOR_VISIBILITY true  // show the mouse cursor\nSAMP_SET_CURSOR_VISIBILITY false // hide the mouse cursor",
    "0B5E": "int coordX,coordY = SF_GET_CURSOR_COORD",
    "0B5F": "int myWindowScreenCoordX, myWindowScreenCoordY = SF_GET_SCREEN_RESOLUTION\nfloat myGameScreenCoordX, myGameScreenCoordY = SF_WINDOW_SCREEN_COORDS_TO_GAME_SCREEN_COORDS {windowscreencoordx} myWindowScreenCoordX {windowscreencoordy} myWindowScreenCoordY",
    "0B60": "int myWindowScreenCoordX, myWindowScreenCoordY = SF_GAME_SCREEN_COORDS_TO_WINDOW_SCREEN_COORDS {gamescreencoordx} 315.19 {gamescreencoordy} 98.89",
    "0B61": "if SAMP_IS_MY_PLAYER_SPAWNED\nthen // our local player had spawned already\nelse // our local player hasn't spawned yet\nend",
    "0B62": "int mySpecialAction\nint myPlayerID = SAMP_GET_PLAYER_ID $scplayer\nif mySpecialAction = SAMP_GET_PLAYER_SPECIAL_ACTION myPlayerID\nthen\n    // do something to mySpecialAction\nelse // myPlayerID is not connected\nend",
    "0B63": "SAMP_UNHOOK_LOCAL_CHAT_COMMAND {chatcommand} \"greedisgood\"",
    "0B64": "if SAMP_IS_PLAYER_NPC {playerid} 17\nthen // player 17 is an NPC\nelse // player 17 is not an NPC\nend",
    "0B65": "int mySpecialAction\nint myPlayerID = SAMP_GET_PLAYER_ID $scplayer\nif myScore = SAMP_GET_PLAYER_SCORE myPlayerID\nthen\n    // do something to myScore\nelse // myPlayerID is not connected\nend",
    "0B66": "int a, r, g, b = SF_HEX_TO_ARGB {color} 0xFF00FF37\n// expected: a = 0xFF, r = 0x00, g = 0xFF, b = 0x37",
    "0B67": "int colorCode = SF_ARGB_TO_HEX {alpha} 0xFF {red} 0x5A {green} 0x14 {blue} 0xCA\n// expected: colorCode = 0xFF5A14CA",
    "0B68": "// draw a green line at the window screen\nSF_D3D_DRAW_LINE {fromcoordx} 100 {fromcoordy} 150 {tocoordx} 720 {tocoordy} 300 {tickness} 1 {color} 0xFF00FF00",
    "0B69": "SF_D3D_DRAW_BORDERLESS_BOX {coordx} 10 {coordy} 300 {width} 600 {height} 400 {color} 0xFFFF7F00 // create orange rectangle",
    "0B6A": "SF_D3D_DRAW_BORDERED_BOX {coordx} 10 {coordy} 300 {width} 600 {height} 400 {color} 0xFFFF7F00 {bordersize} 10 {bordercolor} 0xFFFF00FF  // create orange rectangle with purple border",
    "0B6B": "int textFont = SF_D3D_CREATE_FONT {fontname} \"Calibri\" {size} 9 {flags} 0x04\nint textWidth = SF_D3D_GET_DRAW_WIDTH_OF_TEXT_WITH_FONT textFont {text} \"Hello World!\"\n// do something to textWidth",
    "0B6C": "int textFont = SF_D3D_CREATE_FONT {fontname} \"Calibri\" {size} 9 {flags} 0x04\nint textHeight = SF_D3D_GET_FONT_DRAW_HEIGHT textFont\n// do something to textHeight",
    "0B6D": "SampTextStyle fontTextStyleFlags = SampTextStyle.FCRBold\nfontTextStyleFlags = SampTextStyle.FCRItalic\nfontTextStyleFlags = SampTextStyle.FCRBorder\nSfD3DFont textFont = SF_D3D_CREATE_FONT {fontname} \"Calibri\" {size} 9 {styleFlags} fontTextStyleFlags\n// do something to textFont",
    "0B6E": "int textFont = SF_D3D_CREATE_FONT {fontname} \"Calibri\" {size} 9 {flags} 0x04\n// do something to textFont\nSF_D3D_DELETE_FONT textFont // free renderfont object from memory",
    "0B6F": "int textFont = SF_D3D_CREATE_FONT {fontname} \"Calibri\" {size} 9 {flags} 0x04\nSF_D3D_DRAW_TEXT_WITH_FONT textFont {text} \"Hello World\" {coordx} 400 {coordy} 215 {color} 0xFFFF0000 // write a red colored \"Hello World\" at screen",
    "0B70": "SF_D3D_DRAW_POLYGON {coordx} 500 {coordy} 308 {width} 300 {height} 218 {cornercount} 5 {heading} 60.0 {color} 0xFF00FF00 // draw a green pentagon",
    "0B71": "int myTexture = SF_D3D_LOAD_TEXTURE_FROM_FILE {filepath} \"pic.png\"\n// do something to myTexture",
    "0B72": "int myTexture = SF_D3D_LOAD_TEXTURE_FROM_FILE {filepath} \"pic.png\"\n// do something to myTexture\nSF_D3D_RELEASE_TEXTURE myTexture // free from memory",
    "0B73": "int myTexture = SF_D3D_LOAD_TEXTURE_FROM_FILE {filepath} \"pic.png\"\nSF_D3D_DRAW_TEXTURE myTexture {coordx} 723 {coordy} 333 {width} 50 {height} 30 {heading} 180.0 {contrast} 0xFFFFFFFF // show 100px by 75px picture upside down\nSF_D3D_RELEASE_TEXTURE myTexture",
    "0B74": "if SAMP_SET_CHAT_LINE_PARAMS {chatlineid} 0 {body} \"Hello World!\" {prefix} \"ajom\" {textcolor} 0xFFFFFF00 {prefixcolor} 0xFF00FFFF\nthen // latest chat message becomes \"{ffff00}ajom: {00ffff}Hello World!\"\n    // do something\nelse // chatlineid is invalid\nend",
    "0B75": "{$CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nrepeat\n    wait 100\nuntil samp_is_available\n\nint testPfx = allocate_memory {size} 256\nint testBdy = allocate_memory {size} 256\n\nwhile true\n    int pfxColor, bdyColor\n    \n    wait {time} 3000\n    if {bodyBuffer} testBdy, {prefixBuffer} testPfx, {bodyColor} bdyColor , {prefixColor} pfxColor = samp_get_chat_line {index} 99 // get most recent message\n    then print_formatted_now {format} \"Body Color: %p , Message: %s~n~Prefix Color: %p , Message: %s\" {time} 100 {args} bdyColor testBdy pfxColor testPfx\n    else print_string_now {format} \"Test 1 Latest Chat Line is empty\" {time} 100\n    end\n    \n    wait {time} 3000\n    if {bodyColor} bdyColor , {prefixColor} pfxColor = samp_get_chat_line {index} 99 {bodyBuffer} 0 {prefixBuffer} 0 // get colors only\n    then print_formatted_now {format} \"Body Color: %p~n~Prefix Color: %p\" {time} 100 {args} pfxColor bdyColor\n    else print_string_now {format} \"Test 2 Latest Chat Line is empty\" {time} 100\n    end\n    \n    wait {time} 3000\n    if samp_get_chat_line {index} 99 {bodyBuffer} testBdy {prefixBuffer} testPfx {bodyColor} -1 {prefixColor} -1 // get strings only\n    then print_formatted_now {format} \"Body Message: %s~n~Prefix Message: %s\" {time} 100 {args} testBdy testPfx\n    else print_string_now {format} \"Test 3 Latest Chat Line is empty\" {time} 100\n    end\n    \n    wait {time} 3000\n    if samp_get_chat_line {index} 99 {bodyBuffer} testBdy {prefixBuffer} 0 {bodyColor} bdyColor {prefixColor} -1 // get body only\n    then print_formatted_now {format} \"Body Color: %p , Message: %s\" {time} 100 {args} bdyColor testBdy\n    else print_string_now {format} \"Test 4 Latest Chat Line is empty\" {time} 100\n    end\n    \n    wait {time} 3000\n    if samp_get_chat_line {index} 99 {bodyBuffer} 0 {prefixBuffer} testPfx {bodyColor} -1 {prefixColor} pfxColor // get prefix only\n    then print_formatted_now {format} \"Prefix Color: %p , Message: %s\" {time} 100 {args} pfxColor testPfx\n    else print_string_now {format} \"Test 5 Latest Chat Line is empty\" {time} 100\n    end\nend",
    "0B76": "SAMP_SET_CHAT_INPUT_TEXT \"This message can be found at the input chat box\"",
    "0B77": "int strBufText = ALLOCATE_MEMORY {size} 256\nif strBufText = SAMP_GET_CHAT_INPUT_TEXT\nthen \n// do something to strBufText\nelse \n// strBufText is unwritable\nend\nFREE_MEMORY {address} strBufText",
    "0B78": "SF_LOG_TO_CONSOLE {format} \"My Script has been loaded\"\nSF_LOG_TO_CONSOLE {format} \"Logged: 1 + 1 = %d\" {args} 2",
    "0B79": "SAMP_SET_CHAT_INPUT_VISIBILITY {isvisible} true  // visible\nSAMP_SET_CHAT_INPUT_VISIBILITY {isvisible} false // hidden",
    "0B7A": "int RCIPtr = SAMP_GET_RAKCLIENT_INTERFACE",
    "0B7B": "int RakPeekPtr = SAMP_GET_RAKPEER",
    "0B7C": "int ptr = SAMP_GET_RAKCLIENT_FUNC_BY_INDEX 0",
    "0B7D": "int ptr\nif ptr = SAMP_GET_RPC_FUNC_BY_INDEX {index} 0\nthen // do something\nelse // index is invalid\nend",
    "0B7E": "int ptr\nif ptr = SAMP_GET_RPC_NODE_BY_INDEX {index} 0\nthen // do something\nelse // index is invalid\nend",
    "0B7F": "int ptr = SAMP_GET_INFO_POINTER",
    "0B80": "int clientSidedDialog = sf_dxut_create_dialog {title} \"SF Dialog\"",
    "0B81": "int clientSidedDialog = sf_dxut_create_dialog {title} \"SF Dialog\"\n\n// somewhere in the code\nint eventID, controlID\nif eventID, controlID = sf_dxut_dialog_pop clientSidedDialog\nthen // do something to eventID, controlID\nelse // clientSidedDialog is invalid\nend",
    "0B82": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_BUTTON clientSidedDialog {id} 0 {text} \"Cancel\" {relcoordx} 25 {relcoordy} 200 {width} 50 {height} 10\nSF_DXUT_DIALOG_ADD_BUTTON clientSidedDialog {id} 1 {text} \"Submit\" {relcoordx} 85 {relcoordy} 200 {width} 50 {height} 10",
    "0B83": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 40 {text} \"God Mode\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 41 {text} \"No Collision\" {relcoordx} 10 {relcoordy} 140 {width} 50 {height} 10",
    "0B84": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_SET_COORDS_AND_DIMS clientSidedDialog  {coordx} 900 {coordy} 500 {width} 500 {height} 300",
    "0B85": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nint dialogCoordX, dialogCoordY, dialogWidth, dialogHeight = SF_DXUT_DIALOG_GET_COORDS_AND_DIMS clientSidedDialog",
    "0B86": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\n\nSF_DXUT_DIALOG_SET_VISIBILITY clientSidedDialog {isvisible} true // show dialog\n\nSF_DXUT_DIALOG_SET_VISIBILITY clientSidedDialog {isvisible} false // hide dialog",
    "0B87": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\n\nSF_DXUT_DIALOG_SET_VISIBILITY clientSidedDialog {isvisible} true // show dialog\nif SF_DXUT_DIALOG_IS_VISIBLE clientSidedDialog\nthen // expected\nelse // will not reach this section\nend\n\nSF_DXUT_DIALOG_SET_VISIBILITY clientSidedDialog {isvisible} false // hide dialog\nif SF_DXUT_DIALOG_IS_VISIBLE clientSidedDialog\nthen // will not reach this section\nelse // expected\nend",
    "0B88": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_EDITBOX clientSidedDialog {id} 60 {initialtext} \"Password\" {relcoordx} 10 {relcoordy} 200 {width} 100 {height} 10",
    "0B89": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 40 {text} \"God Mode\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10\n\nint controlText\nif controlText = SF_DXUT_DIALOG_GET_TEXT_OF_CONTROL clientSidedDialog {id} 14\nthen // this section will not be be executed\nelse // clientSidedDialog has no control with ID = 14\nend\nif controlText = SF_DXUT_DIALOG_GET_TEXT_OF_CONTROL clientSidedDialog {id} 40\nthen // expected controlText = \"God Mode\"\nelse // this section will not be be executed\nend",
    "0B8A": "if IS_CHAR_SITTING_IN_ANY_CAR $scplayer\nthen\n    int myCar = STORE_CAR_CHAR_IS_IN_NO_SAVE $scplayer\n    int myCarID = SAMP_GET_CAR_ID myCar\n        // Construct a Bitstream holding a SampRpc.DamageCar data\n    int myBitStream = SAMP_RAKNET_CREATE_BITSTREAM // create bitstream object with class Bitstream\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} myCarID {datatype} SampBitStreamDataType.Short {datasize} DataTypeSize.Short // CarID\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} 0xFFFFFFFF {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int // bodyflags\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} 0xFFFFFFFF {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int // doorflags\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} 0xFF {datatype} SampBitStreamDataType.Byte {datasize} DataTypeSize.Byte // lightflags\n    SAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} 0xFF {datatype} SampBitStreamDataType.Byte {datasize} DataTypeSize.Byte // wheelflags\n        //\n    // Bitstream is ready to be transmitted\n    SAMP_RAKNET_SEND_RPC {rpcid} SampRpc.DamageCar {bitstream} myBitStream\nend",
    "0B8B": "int myRCONCommand = ALLOCATE_MEMORY 58\nmyRCONCommand = STRING_FORMAT \"This_is_a_very_long_String_Example_we_will_send\"\nint textLength = SF_STRLEN myRCONCommand\n    // Construct a Bitstream holding a SampRpc.RconCommand data\nint myBitStream = SAMP_RAKNET_CREATE_BITSTREAM // create bitstream object with class Bitstream\nSAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} SampRpc.RconCommand {datatype} SampBitStreamDataType.Byte {datasize} DataTypeSize.Byte // PacketID\nSAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} textLength {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int // TextLength\nSAMP_RAKNET_BITSTREAM_WRITE myBitStream {value} myRCONCommand {datatype} SampBitStreamDataType.Array {datasize} textLength // CMDText\n    //\n// Bitstream is ready to be transmitted\nsamp_raknet_send_packet {bitstream} myBitStream\nFREE_MEMORY myRCONCommand",
    "0B8C": "if SAMP_IS_CURSOR_ACTIVE\nthen // mouse cursor is shown\nelse // mouse cursor is hidden\nend",
    "0B8D": "SAMP_SET_CURSOR_MODE SampCursorMode.LockCamAndControl // Enables the Mouse Cursor",
    "0B8E": "int cursorMode = SAMP_GET_CURSOR_MODE",
    "0B8F": "float targetWorldCoordX, targetWorldCoordY, targetWorldCoordZ = SF_WINDOW_SCREEN_COORDS_TO_WORLD_COORDS {screencoordx} 750 {screencoordy} 500 {depth} 300.0",
    "0B90": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 40 {text} \"God Mode\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10\nSF_DXUT_DIALOG_SET_VISIBILITY_OF_CONTROL clientSidedDialog {controlid} 40 {isvisible} false // hide control\nSF_DXUT_DIALOG_SET_VISIBILITY_OF_CONTROL clientSidedDialog {controlid} 40 {isvisible} true  // show control",
    "0B91": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_STATIC_TEXT clientSidedDialog {id} 40 {text} \"A Static Text Example\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10",
    "0B92": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 40 {text} \"God Mode\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 41 {text} \"No Collision\" {relcoordx} 10 {relcoordy} 140 {width} 50 {height} 10\n\n// somewhere in code\nif SF_DXUT_DIALOG_IS_CHECKBOX_CHECKED clientSidedDialog 40\nthen // checkbox control with id = 40 is checked\nelse // checkbox control with id = 40 is unchecked\nend",
    "0B93": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_SET_BACKGROUND_COLOR clientSidedDialog {color} 0xFF555555 // grey background",
    "0B94": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_STATIC_TEXT clientSidedDialog {id} 40 {text} \"A Static Text Example\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10\n\n// test invalid control\nif SF_DXUT_DIALOG_SET_TEXT_OF_CONTROL clientSidedDialog {id} 9 {text} \"New Text\"\nthen // this section will not execute\nelse // clientSidedDialog has no control with id = 9\nend\n\n// test valid control\nif SF_DXUT_DIALOG_SET_TEXT_OF_CONTROL clientSidedDialog {id} 40 {text} \"New Text\"\nthen // The text written at the static text control is now \"New Text\"\nelse // this section will not execute\nend",
    "0B95": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 40 {text} \"God Mode\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10\n\nSF_DXUT_DIALOG_SET_VISIBILITY_OF_CONTROL clientSidedDialog {controlid} 40 {isvisible} false // hide control\nif SF_DXUT_DIALOG_IS_CONTROL_VISIBLE clientSidedDialog {controlid} 40\nthen // this section will not be executed\nelse // do something\nend\n\nSF_DXUT_DIALOG_SET_VISIBILITY_OF_CONTROL clientSidedDialog {controlid} 40 {isvisible} true  // show control\nif SF_DXUT_DIALOG_IS_CONTROL_VISIBLE clientSidedDialog {controlid} 40\nthen // do something\nelse // this section will not be executed\nend",
    "0B96": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_SLIDER clientSidedDialog {id} 80 {relcoordx} 80 {relcoordy} 200 {width} 100 {height} 20 {maxvalue} 100",
    "0B97": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_SLIDER clientSidedDialog {id} 80 {relcoordx} 80 {relcoordy} 200 {width} 100 {height} 20 {maxvalue} 100\n\n// somewhere in the code\nint sliderVal = SF_DXUT_DIALOG_GET_SLIDER_VALUE clientSidedDialog {id} 80",
    "0B98": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_SLIDER clientSidedDialog {id} 80 {relcoordx} 80 {relcoordy} 200 {width} 100 {height} 20 {maxvalue} 100\nSF_DXUT_DIALOG_SET_SLIDER_VALUE clientSidedDialog {id} 80 {value} 50 // put the thumb at the center of the slider",
    "0B99": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400",
    "0B9A": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\nif SF_DXUT_DIALOG_INSERT_LISTBOX_ELEMENT clientSidedDialog {id} 100 {text} \"Refill Health\" {data} 1 {index} 0\nthen SF_DXUT_DIALOG_INSERT_LISTBOX_ELEMENT clientSidedDialog {id} 100 {text} \"Refill Armour\" {data} 2 {index} 1\nelse // failed to insert the element\nend",
    "0B9B": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\nif SF_DXUT_DIALOG_INSERT_LISTBOX_ELEMENT clientSidedDialog {id} 100 {text} \"Refill Health\" {data} 1 {index} 0\nthen SF_DXUT_DIALOG_INSERT_LISTBOX_ELEMENT clientSidedDialog {id} 100 {text} \"Refill Armour\" {data} 2 {index} 1\nelse // failed to insert the element\nend\n\n// somewhere in the code\nint selIndex, elCount = SF_DXUT_DIALOG_GET_SELECTED_LISTBOX_ELEMENT clientSidedDialog 100",
    "0B9C": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\nif SF_DXUT_DIALOG_INSERT_LISTBOX_ELEMENT clientSidedDialog {id} 100 {text} \"Refill Health\" {data} 1 {index} 0\nthen SF_DXUT_DIALOG_INSERT_LISTBOX_ELEMENT clientSidedDialog {id} 100 {text} \"Refill Armour\" {data} 2 {index} 1\nelse // failed to insert the element\nend\n\nif SF_DXUT_DIALOG_DELETE_LISTBOX_ELEMENT clientSidedDialog {id} 100 {index} 1\nthen // 1st element listbox with id = 100 has been removed\nelse // listbox element cannot be found\nend",
    "0B9D": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\nif SF_DXUT_DIALOG_INSERT_LISTBOX_ELEMENT clientSidedDialog {id} 100 {text} \"Refill Health\" {data} 1 {index} 0\nthen SF_DXUT_DIALOG_INSERT_LISTBOX_ELEMENT clientSidedDialog {id} 100 {text} \"Refill Armour\" {data} 2 {index} 1\nelse // failed to insert the element\nend\n\nint elText, elData\nif elText, elData = SF_DXUT_DIALOG_GET_LISTBOX_ELEMENT clientSidedDialog {id} 100 {index} 1\nthen // do something to elText, elData\nelse // listbox element cannot be found\nend",
    "0B9E": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 40 {text} \"God Mode\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 41 {text} \"No Collision\" {relcoordx} 10 {relcoordy} 140 {width} 50 {height} 10\nSF_DXUT_DIALOG_SET_STATUS_OF_CHECKBOX clientSidedDialog {id} 41 {ischecked} true",
    "0B9F": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_SET_TITLE_VISIBILITY clientSidedDialog {isVisible} false // hide the dialog's title",
    "0BA0": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\n\nSF_DXUT_DIALOG_SET_TITLE_VISIBILITY clientSidedDialog {isVisible} false // hide the dialog's title\nif SF_DXUT_DIALOG_IS_TITLE_VISIBLE clientSidedDialog\nthen // this section will not execute\nelse // expected\nend\n\nSF_DXUT_DIALOG_SET_TITLE_VISIBILITY clientSidedDialog {isVisible} true // show the dialog's title\nif SF_DXUT_DIALOG_IS_TITLE_VISIBLE clientSidedDialog\nthen // expected\nelse // this section will not execute\nend",
    "0BA1": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_SET_MINIMIZED clientSidedDialog {isminimized} true // minimize the dialog",
    "0BA2": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\n\nSF_DXUT_DIALOG_SET_MINIMIZED clientSidedDialog {isminimized} false // minimize the dialog\nif SF_DXUT_DIALOG_IS_MINIMIZED clientSidedDialog\nthen // this section will not execute\nelse // expected\nend\n\nSF_DXUT_DIALOG_SET_MINIMIZED clientSidedDialog {isminimized} true // maximize the dialog\nif SF_DXUT_DIALOG_IS_MINIMIZED clientSidedDialog\nthen // expected\nelse // this section will not execute\nend",
    "0BA3": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\n\n\n// somewhere in the code\nSF_DXUT_DIALOG_DELETE_CONTROL clientSidedDialog {id} 100 // delete the listbox control",
    "0BA4": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\n\n// somewhere in the code\nSF_DXUT_DIALOG_DELETE clientSidedDialog",
    "0BA5": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_BUTTON clientSidedDialog {id} 0 {text} \"Cancel\" {relcoordx} 25 {relcoordy} 200 {width} 50 {height} 10\nSF_DXUT_DIALOG_ADD_BUTTON clientSidedDialog {id} 1 {text} \"Submit\" {relcoordx} 85 {relcoordy} 200 {width} 50 {height} 10\nSF_DXUT_DIALOG_SET_FOCUSED_CONTROL clientSidedDialog {id} 0 // pressing enter will simulate like the user pressed the cancel button",
    "0BA6": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\n\n// somewhere in the code\nSF_DXUT_DIALOG_SET_DIMS_OF_CONTROL clientSidedDialog {id} 100 {width} 150 {height} 700 // set new dimensions for the listbox",
    "0BA7": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\n\nint lbWith, lbHeight = SF_DXUT_DIALOG_GET_DIMS_OF_CONTROL clientSidedDialog {id} 100\n// expected lbWith = 150, lbHeight = 400",
    "0BA8": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\n\n// somewhere in the code\nSF_DXUT_DIALOG_SET_COORDS_OF_CONTROL clientSidedDialog {id} 100 {relcoordx} 20 {relcoordy} 150 // change the window position of our listbox",
    "0BA9": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_LISTBOX clientSidedDialog {id} 100 {relcoordx} 10 {relcoordy} 200 {width} 150 {height} 400\n\nint lbCoordX, lbCoordY = SF_DXUT_DIALOG_GET_COORDS_OF_CONTROL clientSidedDialog {id} 100\n// expected lbCoordX = 10, lbCoordY = 200",
    "0BAA": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 40 {text} \"God Mode\" {relcoordx} 10 {relcoordy} 80 {width} 50 {height} 10\nSF_DXUT_DIALOG_ADD_CHECKBOX clientSidedDialog {id} 41 {text} \"No Collision\" {relcoordx} 10 {relcoordy} 140 {width} 50 {height} 10\nSF_DXUT_DIALOG_SET_COLOR_OF_CHECKBOX clientSidedDialog {id} 40 {color} 0xFF00FF00 // Green\nSF_DXUT_DIALOG_SET_COLOR_OF_CHECKBOX clientSidedDialog {id} 41 {color} 0xFFFF00FF // Purple",
    "0BAB": "int clientSidedDialog = SF_DXUT_CREATE_DIALOG {title} \"SF Dialog\"\nif SF_DXUT_DIALOG_EXIST clientSidedDialog\nthen // expected\nelse // this section will not execute\nend\n\nSF_DXUT_DIALOG_DELETE clientSidedDialog\nif SF_DXUT_DIALOG_EXIST clientSidedDialog\nthen // this section will not execute\nelse // expected\nend",
    "0BAC": "int svSettPtr = SAMP_GET_SERVER_SETTINGS_POINTER",
    "0BAD": "int poolsPtr = SAMP_GET_POOLS_POINTER",
    "0BAE": "int chatinfoPtr = SAMP_GET_CHAT_INFO_POINTER",
    "0BAF": "int inputinfoPtr = SAMP_GET_CHAT_INPUT_INFO_POINTER",
    "0BB0": "int dialogInfoPtr = SAMP_GET_DIALOG_INFO_POINTER",
    "0BB1": "int killInfoPtr = SAMP_GET_KILL_INFO_POINTER",
    "0BB2": "int miscInfoPtr = SAMP_GET_MISC_INFO_POINTER",
    "0BB3": "int textDrawPoolPtr = SAMP_GET_TEXTDRAW_POOL_POINTER",
    "0BB4": "int objPoolPtr = SAMP_GET_OBJECT_POOL_POINTER",
    "0BB5": "int gzPoolPtr = SAMP_GET_GANGZONE_POOL_POINTER",
    "0BB6": "int text3DPoolPtr = SAMP_GET_TEXTLABEL_POOL_POINTER",
    "0BB7": "int playerPoolPtr = SAMP_GET_PLAYER_POOL_POINTER",
    "0BB8": "int carPoolPtr = SAMP_GET_CAR_POOL_POINTER",
    "0BB9": "int pickupPoolPtr = SAMP_GET_PICKUP_POOL_POINTER",
    "0BBA": "int onFootData = ALLOCATE_MEMORY {size} 68 // stOnFootData occupies 68 bytes in 0.3.7 R1\nif onFootData = SAMP_STORE_PLAYER_ONFOOT_DATA {id} 17\nthen // do something to onFootData\nelse // buffer or player id is invalid\nend\nFREE_MEMORY {address} onFootData",
    "0BBB": "int inCarData = ALLOCATE_MEMORY {size} 63 // stInCarData occupies 63 bytes in 0.3.7 R1\nif inCarData = SAMP_STORE_PLAYER_DRIVING_DATA {id} 17\nthen // do something to inCarData\nelse // buffer or player id is invalid\nend\nFREE_MEMORY {address} inCarData",
    "0BBC": "int passengerData = ALLOCATE_MEMORY {size} 24 // stPassengerData occupies 24 bytes in 0.3.7 R1\nif passengerData  = SAMP_STORE_PLAYER_PASSENGER_DATA {id} 17\nthen // do something to passengerData \nelse // buffer or player id is invalid\nend\nFREE_MEMORY {address} passengerData",
    "0BBD": "int trailerData = ALLOCATE_MEMORY {size} 54 // stPassengerData occupies 54 bytes in 0.3.7 R1\nif trailerData = SAMP_STORE_PLAYER_TRAILER_DATA {id} 17\nthen // do something to trailerData\nelse // buffer or player id is invalid\nend\nFREE_MEMORY {address} trailerData",
    "0BBE": "int aimData = ALLOCATE_MEMORY {size} 31 // stAimData occupies 31 bytes in 0.3.7 R1\nif aimData = SAMP_STORE_PLAYER_AIM_DATA {id} 17\nthen // do something to aimData\nelse // buffer or player id is invalid\nend\nFREE_MEMORY {address} aimData",
    "0BBF": "SAMP_SEND_RCON_COMMAND {command} \"/login\"",
    "0BC0": "int onFootData = ALLOCATE_MEMORY {size} 68 // stOnFootData occupies 68 bytes in 0.3.7 R1\n// do something to fill the contents of onFootData\nSAMP_SEND_ONFOOT_DATA {stOnFootData} onFootData\nFREE_MEMORY {address} onFootData",
    "0BC1": "int inCarData = ALLOCATE_MEMORY {size} 63 // stInCarData occupies 63 bytes in 0.3.7 R1\n// do something to fill the contents of inCarData\nSAMP_SEND_DRIVING_DATA {stInCarData} inCarData\nFREE_MEMORY {address} inCarData",
    "0BC2": "int passengerData = ALLOCATE_MEMORY {size} 24 // stPassengerData occupies 24 bytes in 0.3.7 R1\n// do something to fill the contents of passengerData\nSAMP_SEND_PASSENGER_DATA {stPassengerData} passengerData\nFREE_MEMORY {address} passengerData",
    "0BC3": "int aimData = ALLOCATE_MEMORY {size} 31 // stAimData occupies 31 bytes in 0.3.7 R1\n// do something to fill the contents of aimData\nSAMP_SEND_AIM_DATA {stAimData} aimData\nFREE_MEMORY {address} aimData",
    "0BC4": "int bulletData = ALLOCATE_MEMORY {size} 40 // stBulletData occupies 40 bytes in 0.3.7 R1\n// do something to fill the contents of bulletData\nSAMP_SEND_BULLET_DATA {stBulletData} bulletData\nFREE_MEMORY {address} bulletData",
    "0BC5": "int trailerData = ALLOCATE_MEMORY {size} 54 // stTrailerData occupies 54 bytes in 0.3.7 R1\n// do something to fill the contents of trailerData\nSAMP_SEND_TRAILER_DATA {stTrailerData} trailerData\nFREE_MEMORY {address} trailerData",
    "0BC6": "int unoccupiedCarData = ALLOCATE_MEMORY {size} 67 // stUnoccupiedData occupies 67 bytes in 0.3.7 R1\n// do something to fill the contents of unoccupiedCarData\nSAMP_SEND_UNOCCUPIEDCAR_DATA {stUnoccupiedData} unoccupiedCarData\nFREE_MEMORY {address} unoccupiedCarData",
    "0BC7": "int specData = ALLOCATE_MEMORY {size} 18 // stSpectatorData occupies 18 bytes in 0.3.7 R1\n// do something to fill the contents of specData\nSAMP_SEND_SPECTATOR_DATA {stSpectatorData} specData\nFREE_MEMORY {address} specData",
    "0BC8": "SAMP_SEND_CLICK_PLAYER {playerId} 17 {clickSourceId} 0 // tell the server I clicked player 17 at scoreboard",
    "0BC9": "SAMP_SEND_DIALOG_RESPONSE {dialogId} 71 {whichButton} SampDialogButton.LeftOrCenter {itemId} 3 {inputText} \"Refill Health\"",
    "0BCA": "SAMP_SEND_CLICK_TEXTDRAW {textDrawId} 89",
    "0BCB": "SAMP_SEND_GIVE_DAMAGE {playerId} 53 {damage} SampWeaponDamage.Sniper {weapon} WeaponType.Sniper {bodyPart} SampBodyPart.Head // Inform server that we headshotted by player 53 using a sniper rifle",
    "0BCC": "SAMP_SEND_TAKE_DAMAGE {playerId} 53 {damage} SampWeaponDamage.Sniper {weapon} WeaponType.Sniper {bodyPart} SampBodyPart.Head // Inform server that we have been headshotted by player 53",
    "0BCD": "SAMP_SEND_EDIT_OBJECT {isLocalObject} false {response} SampEditObjectResponse.Update {id} 13 {coordX} 200.48 {coordY} 1523.3 {coordZ} 20.0 {pitch} 45.7 {roll} -15.3 {yaw} 13.0",
    "0BCE": "SAMP_SEND_EDIT_ATTACHED_OBJECT {response} SampEditObjectResponse.Final {index} 3 {model} 910 {pedBone} PedBone.Head {offsetX} 0.0 {offsetY} 1.0 {offsetZ} 0.0 {pitch} 45.7 {roll} -15.3 {yaw} 13.0 {scaleX} 1.0 {scaleY} 1.0 {scaleZ} 1.0",
    "0BD0": "SAMP_SEND_REQUEST_SPAWN",
    "0BD1": "SAMP_SEND_PICKED_UP_PICKUP {id} 114",
    "0BD2": "SAMP_SEND_MENU_SELECT_ROW {elementId} 8",
    "0BD3": "SAMP_SEND_QUIT_MENU",
    "0BD4": "if IS_CHAR_SITTING_IN_ANY_CAR $scplayer\nthen\n    int myCar = STORE_CAR_CHAR_IS_IN_NO_SAVE\n    int myCarID = SAMP_GET_CAR_ID myCar\n    SAMP_SEND_CAR_DESTROYED {id} myCarID\nend",
    "0BD5": "if SAMP_IS_SCOREBOARD_VISIBLE\nthen // scoreboard is shown\nelse // scoreboard is hidden\nend",
    "0BD6": "SAMP_SET_SCOREBOARD_VISIBILITY {isVisible} true // scoreboard is now shown\nwait 3000\nSAMP_SET_SCOREBOARD_VISIBILITY {isVisible} false // scoreboard is now hidden",
    "0BD7": "int contentBuf = ALLOCATE_MEMORY {size} 500\nSAMP_GET_DIALOG_CONTENT {contentBuffer} contentBuf\n// do something to contentBuf\nFREE_MEMORY {address} contentBuf",
    "0BD8": "int titleBuf = ALLOCATE_MEMORY {size} 500\nSAMP_GET_DIALOG_TITLE {buffer} titleBuf\n// do something to titleBuf\nFREE_MEMORY {address} titleBuf",
    "0BD9": "SAMP_SET_ACTIVE_DIALOG_ENVIRONMENT {isClientSide} true",
    "0BDA": "if SAMP_IS_ACTIVE_DIALOG_CLIENTSIDE\nthen // opened dialog is client-sided\nelse // either no dialog is opened or the opened dialog is not client-sided\nend",
    "0BDB": "if SAMP_IS_CHAT_VISIBLE\nthen // chat lines are shown\nelse // chat lines are hidden\nend",
    "0BDC": "int chatDisplayMode = SAMP_GET_CHAT_DISPLAY_MODE",
    "0BDD": "SAMP_SET_CHAT_DISPLAY_MODE {mode} SampChatDisplayMode.NoShadow",
    "0BDE": "{$CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nSF_PAUSE_SCRIPT {threadId} 0 // pauses this script's main thread\n\n// this part will not be executed until SF_RESUME_SCRIPT is called\nwhile true\n    wait 0\n    // do something\nend",
    "0BDF": "// Script Example\n// The main thread will execute after the user types \"/resumethread\"\n\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nSAMP_HOOK_CHAT_COMMAND_AS_LOCAL {chatcommand} \"resumethread\" {callbacklabel} @ChatCallback_ResumeThread\n\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n\n// This part of the main thread will not be reached until SF_RESUME_SCRIPT is called\nwhile true\n    wait 2000\n    PRINT_STRING_NOW \"Main Loop Executed!\" {time} 1000\nend\n\n\n:ChatCallback_ResumeThread\n    SF_RESUME_SCRIPT {id} 0 // Resumes this script's main thread\nSF_COMMAND_RETURN // end of callback",
    "0BE0": "/*\n * Check the following commands for example usage of this command:\n * * SAMP_RAKNET_HOOK_OUTCOMING_RPC\n * * SAMP_RAKNET_HOOK_OUTCOMING_PACKET\n * * SAMP_RAKNET_HOOK_INCOMING_RPC\n * * SAMP_RAKNET_HOOK_INCOMING_PACKET\n */\n\nSAMP_RAKNET_HOOK_RETURN {unblockData} true",
    "0BE1": "// Example: Manipulated RPC Damage Sync\n// * Everytime we take damage from a player, the damage indication will not be sent to the server\n// * Everytime we deal damage to a player by any means(punching, chainsaw, MP5, etc), the weapon and its damage is modified into shotgun(weapon with highest damage) XD lol\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nif not SAMP_RAKNET_HOOK_OUTCOMING_RPC {callbackLabel} @RPC_Out\nthen TERMINATE_THIS_CUSTOM_SCRIPT\nend\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:RPC_Out // all transmitted RPC will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    if packetId == SampRpc.GiveTakeDamage\n    then\n        Bitstream bitStream = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.Bitstream\n        bool isTakeDamage = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Bool\n        if isTakeDamage == true\n        then SAMP_RAKNET_HOOK_RETURN {unblockData} false // end this callback and block transmission of this data\n        else // I'm dealing damage to another player\n            int saveWriteOffset = SAMP_RAKNET_BITSTREAM_GET_WRITE_OFFSET bitStream // store the original write offset to be used later\n            SAMP_RAKNET_BITSTREAM_SET_WRITE_OFFSET bitStream {offset} 24 // skip isTakeDamage and PlayerID \n            SAMP_RAKNET_BITSTREAM_WRITE bitStream {value} SampWeaponDamage.Shotgun_3meters {dataType} SampBitStreamDataType.Float {dataSize} 4\n            SAMP_RAKNET_BITSTREAM_WRITE bitStream {value} WeaponType.Shotgun {dataType} SampBitStreamDataType.Int {dataSize} 4\n            SAMP_RAKNET_BITSTREAM_SET_WRITE_OFFSET bitStream {offset} saveWriteOffset // ALWAYS Set the Write Offset to its original value OR ELSE GTA SA WILL CRASH\n        end\n    end\nSAMP_RAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to transmit this data",
    "0BE2": "// Example: Super Saiyan Dash (Fugga) Troll Hack\n// Our Character will appear normal from our client's perspective. But our character will appear to be dashing insanely fast at the client of all remote players, and rams everything that comes near >-:D Muhahaha!\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nif not SAMP_RAKNET_HOOK_OUTCOMING_PACKET {callbackLabel} @Packet_Out\nthen TERMINATE_THIS_CUSTOM_SCRIPT\nend\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:Packet_Out // all transmitted Packet will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    if packetId == SampPacket.OnFootSync\n    then\n        Bitstream bitStream = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.Bitstream\n        int saveWriteOffset = SAMP_RAKNET_BITSTREAM_GET_WRITE_OFFSET bitStream // store the original write offset to be used later\n        SAMP_RAKNET_BITSTREAM_SET_WRITE_OFFSET bitStream {offset} 56 // offset to my character's coordinates\n        float offsetX = generate_random_float_in_range {min} 0.0 {max} 5.0\n        float offsetY = generate_random_float_in_range {min} 0.0 {max} 5.0\n        float offsetZ = generate_random_float_in_range {min} 0.0 {max} 5.0\n        float newCoordX, newCoordY, newCoordZ = get_offset_from_char_in_world_coords $scplayer {xOffset} offsetX {yOffset} offsetY {zOffset} offsetZ\n        SAMP_RAKNET_BITSTREAM_WRITE bitStream {value} newCoordX {dataType} SampBitStreamDataType.Float {dataSize} 4\n        SAMP_RAKNET_BITSTREAM_WRITE bitStream {value} newCoordY {dataType} SampBitStreamDataType.Float {dataSize} 4\n        SAMP_RAKNET_BITSTREAM_WRITE bitStream {value} newCoordZ {dataType} SampBitStreamDataType.Float {dataSize} 4\n        SAMP_RAKNET_BITSTREAM_SKIP_BITS bitStream {bitCount} 256 // offset to my character's velocity per frame (50FPS basis)\n        float velocityX = generate_random_float_in_range {min} 0.0 {max} 0.8660254038\n        float velocityY = generate_random_float_in_range {min} 0.0 {max} 0.8660254038\n        float velocityZ = generate_random_float_in_range {min} 0.0 {max} 0.8660254038\n        SAMP_RAKNET_BITSTREAM_WRITE bitStream {value} velocityX {dataType} SampBitStreamDataType.Float {dataSize} 4\n        SAMP_RAKNET_BITSTREAM_WRITE bitStream {value} velocityY {dataType} SampBitStreamDataType.Float {dataSize} 4\n        SAMP_RAKNET_BITSTREAM_WRITE bitStream {value} velocityZ {dataType} SampBitStreamDataType.Float {dataSize} 4\n        SAMP_RAKNET_BITSTREAM_SET_WRITE_OFFSET bitStream {offset} saveWriteOffset // ALWAYS Set the Write Offset to its original value OR ELSE GTA SA WILL CRASH\n    end\nSAMP_RAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to transmit this data",
    "0BE3": "// Example: Prints the Received chat message like a GXT\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nif not SAMP_RAKNET_HOOK_INCOMING_RPC {callbackLabel} @RPC_In\nthen TERMINATE_THIS_CUSTOM_SCRIPT\nend\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:RPC_In // all received Packet will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    if packetId == SampRpc.Chat\n    then\n        Bitstream bitStream = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.Bitstream\n        int strLen = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.BYTE\n            // print_* commands crashes the game when the string exceeds 125, so we need to limit it\n        if strLen > 124\n        then strLen = 124\n        end\n            //\n        strLen++ // include null terminator\n        int strBuf = ALLOCATE_MEMORY {size} strLen\n        strLen-- // revert back to original string length\n        SAMP_RAKNET_BITSTREAM_READ_ARRAY bitStream {buffer} strBuf {size} strLen\n        WRITE_MEMORY_WITH_OFFSET {address} strBuf {offset} strLen {size} 1 {value} 0 // assure the end of the string is a null terminator\n        PRINT_STRING_NOW strBuf\n        FREE_MEMORY {address} strBuf\n        SAMP_RAKNET_BITSTREAM_RESET_READ_POINTER bitStream // This assures that RakNet will read the entire data once the detour finishes\n    end\nSAMP_RAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to process the data",
    "0BE4": "// Example: No Unexpected Unoccupied Car Modification\n// Prevents all attempts of the server to manipulate unocuppied cars\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nif not SAMP_RAKNET_HOOK_INCOMING_PACKET {callbackLabel} @Packet_In\nthen TERMINATE_THIS_CUSTOM_SCRIPT\nend\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:Packet_In // all received Packet will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    if packetId == SampPacket.UnoccupiedCarSync\n    then SAMP_RAKNET_HOOK_RETURN {unblockData} false // end this callback and block this data\n    end\nSAMP_RAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to process the data",
    "0BE5": "/*\n * Check the following commands for example usage of this command:\n * * SAMP_RAKNET_HOOK_OUTCOMING_RPC\n * * SAMP_RAKNET_HOOK_OUTCOMING_PACKET\n * * SAMP_RAKNET_HOOK_INCOMING_RPC\n * * SAMP_RAKNET_HOOK_INCOMING_PACKET\n */\n\nBitstream bitStream = SAMP_RAKNET_HOOK_GET_PARAM SampRakNetHookParam.Bitstream \n// do something to fill data of bitStream",
    "0BE7": "// See SAMP_RAKNET_HOOK_OUTCOMING_RPC command's snippet for example usage of this command\n\nBitstream bitStream\n// do something to fill data of bitStream\n\nint value = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Short {dataSize} 2\n// do something to value",
    "0BE8": "// See SAMP_RAKNET_HOOK_INCOMING_RPC command's snippet for example usage of this command\n\nBitstream bitStream\nint strBuf, strLen\n// do something to bitStream, strBuf, strLen\n\nSAMP_RAKNET_BITSTREAM_READ_ARRAY bitStream {buffer} strBuf {size} strLen",
    "0BE9": "// See SAMP_RAKNET_HOOK_INCOMING_RPC command's snippet for example usage of this command\n\nBitstream bitStream\n// do something to bitStream\n\nSAMP_RAKNET_BITSTREAM_RESET_READ_POINTER bitStream // Read Pointer is now back to its original value",
    "0BEA": "/*\n * Check the following commands for example usage of this command:\n * * SAMP_RAKNET_HOOK_OUTCOMING_RPC\n * * SAMP_RAKNET_HOOK_OUTCOMING_PACKET\n * * SAMP_RAKNET_HOOK_INCOMING_RPC\n * * SAMP_RAKNET_HOOK_INCOMING_PACKET\n */\n\nint myBitstream = SAMP_RAKNET_CREATE_BITSTREAM\nSAMP_RAKNET_BITSTREAM_SET_WRITE_OFFSET bitStream {offset} 24 // set the write offset at the 4th byte\nSAMP_RAKNET_BITSTREAM_WRITE myBitstream {value} 0x83FF3ABC {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int\nSAMP_RAKNET_BITSTREAM_RESET_WRITE_POINTER bitStream // write offset is now at its default value",
    "0BEB": "// See SAMP_RAKNET_HOOK_INCOMING_RPC command's snippet for example usage of this command\n\nint myBitstream = SAMP_RAKNET_CREATE_BITSTREAM\nSAMP_RAKNET_BITSTREAM_SKIP_BITS bitStream {bitCount} 24 // increase the write offset and read offset by 3 bytes\nSAMP_RAKNET_BITSTREAM_WRITE myBitstream {value} 0x83FF3ABC {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int\nint value = SAMP_RAKNET_BITSTREAM_READ myBitstream {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int\n// expected: value = 0x83FF3ABC",
    "0BEC": "/*\n * Check the following commands for example usage of this command:\n * * SAMP_RAKNET_HOOK_OUTCOMING_RPC\n * * SAMP_RAKNET_HOOK_OUTCOMING_PACKET\n * * SAMP_RAKNET_HOOK_INCOMING_RPC\n * * SAMP_RAKNET_HOOK_INCOMING_PACKET\n */\n\nint myBitstream = SAMP_RAKNET_CREATE_BITSTREAM\nSAMP_RAKNET_BITSTREAM_SET_WRITE_OFFSET bitStream {offset} 24 // set the write offset at the 4th byte\nSAMP_RAKNET_BITSTREAM_WRITE myBitstream {value} 0x83FF3ABC {datatype} SampBitStreamDataType.Int {datasize} DataTypeSize.Int",
    "0BEE": "Bitstream bitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to fill the bitStream with data\n\nint bitsUsed = SAMP_RAKNET_BITSTREAM_GET_NUMBER_OF_BITS_USED bitStream\n// do something to bitsUsed",
    "0BEF": "Bitstream bitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to fill the bitStream with data\n\nint bytesUsed = SAMP_RAKNET_BITSTREAM_GET_NUMBER_OF_BYTES_USED bitStream\n// do something to bytesUsed",
    "0BF0": "Bitstream bitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to fill the bitStream with data\n\nint bitsUnread = SAMP_RAKNET_BITSTREAM_GET_NUMBER_OF_UNREAD_BITS bitStream\n// do something to bitsUnread",
    "0BF1": "/*\n * Check the following commands for example usage of this command:\n * * SAMP_RAKNET_HOOK_OUTCOMING_RPC\n * * SAMP_RAKNET_HOOK_OUTCOMING_PACKET\n */\n\nBitstream myBitstream\n// do something to fill data of myBitstream\n\nint checkWriteOffset = SAMP_RAKNET_BITSTREAM_GET_WRITE_OFFSET myBitstream\n// do something to checkWriteOffset",
    "0BF2": "Bitstream bitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to fill the bitStream with data\n\nint readOffset = SAMP_RAKNET_BITSTREAM_GET_READ_OFFSET bitStream\n// do something to readOffset",
    "0BF3": "Bitstream bitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to fill the bitStream with data\n\nint dataPtr = SAMP_RAKNET_BITSTREAM_GET_DATA_POINTER bitStream\n// do something to dataPtr",
    "0BF4": "// Example: Echo Shown Dialog to local chat\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nif not SAMP_RAKNET_HOOK_INCOMING_RPC {callbackLabel} @RPC_In\nthen TERMINATE_THIS_CUSTOM_SCRIPT\nend\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:RPC_In // all received Packet will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    if packetId == SampRpc.ScrShowDialog\n    then\n        int strLen\n        int strBuf = ALLOCATE_MEMORY {size} 4097 // max CString size\n\n        Bitstream bitStream = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.Bitstream\n\n        int dialogID = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Short\n        int dialogStyle = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Byte\n        SAMP_ADD_MESSAGE_TO_CHAT {format} \"DialogID=%hu , DialogStyle=%hhu\" {color} 0xFF00FF00 {args} dialogID dialogStyle\n            \n        strLen = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Byte\n        SAMP_RAKNET_BITSTREAM_READ_ARRAY bitStream {buffer} strBuf {size} strLen\n        WRITE_MEMORY_WITH_OFFSET {address} strBuf {offset} strLen {size} 1 {value} 0 // assure the end of the string is a null terminator\n        SAMP_ADD_MESSAGE_TO_CHAT {format} \"DialogTitle=%s\" {color} 0xFF00FF00 {args} strBuf\n            \n        strLen = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Byte\n        SAMP_RAKNET_BITSTREAM_READ_ARRAY bitStream {buffer} strBuf {size} strLen\n        WRITE_MEMORY_WITH_OFFSET {address} strBuf {offset} strLen {size} 1 {value} 0 // assure the end of the string is a null terminator\n        SAMP_ADD_MESSAGE_TO_CHAT {format} \"DialogButton1Text=%s\" {color} 0xFF00FF00 {args} strBuf\n            \n        strLen = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Byte\n        SAMP_RAKNET_BITSTREAM_READ_ARRAY bitStream {buffer} strBuf {size} strLen\n        WRITE_MEMORY_WITH_OFFSET {address} strBuf {offset} strLen {size} 1 {value} 0 // assure the end of the string is a null terminator\n        SAMP_ADD_MESSAGE_TO_CHAT {format} \"DialogButton2Text=%s\" {color} 0xFF00FF00 {args} strBuf\n            \n        SAMP_RAKNET_BITSTREAM_DECODE_COMPRESSED_STRING bitStream {buffer} strBuf {buffersize} 4097\n        SAMP_ADD_MESSAGE_TO_CHAT {format} \"DialogInfo=%s\" {color} 0xFF00FF00 {args} strBuf\n\n        FREE_MEMORY {address} strBuf\n        RAKNET_BIT_STREAM_RESET_READ_POINTER bitStream // This assures that RakNet will read the entire data once the detour finishes\n    end\nRAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to process the data",
    "0BF5": "// Example: Edit Dialog Info during RPC Reception\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nif not SAMP_RAKNET_HOOK_INCOMING_RPC {callbackLabel} @RPC_In\nthen TERMINATE_THIS_CUSTOM_SCRIPT\nend\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:RPC_In // all received Packet will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    if packetId == SampRpc.ScrShowDialog\n    then\n        Bitstream bitStream = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.Bitstream\n        SAMP_RAKNET_BITSTREAM_SKIP_BITS bitStream {bitCount} 24 // skip dialogID, dialogStyle\n        int strLen\n\n        strLen = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Byte\n        strLen *= 8 // convert bits to Bytes\n        SAMP_RAKNET_BITSTREAM_SKIP_BITS bitStream {bitCount} strLen // skip dialogTitle\n\n        strLen = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Byte\n        strLen *= 8 // convert bits to Bytes\n        SAMP_RAKNET_BITSTREAM_SKIP_BITS bitStream {bitCount} strLen // skip dialogButton1\n\n        strLen = SAMP_RAKNET_BITSTREAM_READ bitStream {dataType} SampBitStreamDataType.Byte\n        strLen *= 8 // convert bits to Bytes\n        SAMP_RAKNET_BITSTREAM_SKIP_BITS bitStream {bitCount} strLen // skip dialogButton2\n\n        int saveWriteOffset = SAMP_RAKNET_BITSTREAM_GET_WRITE_OFFSET myBitstream\n        int readOffset = SAMP_RAKNET_BITSTREAM_GET_READ_OFFSET bitStream\n        SAMP_RAKNET_BITSTREAM_SET_WRITE_OFFSET bitStream {offset} readOffset\n        SAMP_RAKNET_BITSTREAM_ENCODE_STRING bitStream {buffer} \"AJOM Test~n~~n~The info has now been changed into this text!\" {buffersize} 61\n\n        SAMP_RAKNET_BITSTREAM_RESET_READ_POINTER bitStream // This assures that RakNet will read the entire data once the detour finishes\n        SAMP_RAKNET_BITSTREAM_SET_WRITE_OFFSET bitStream {offset} saveWriteOffset // ALWAYS Set the Write Offset to its original value OR ELSE GTA SA WILL CRASH\n    end\nRAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to process the data",
    "0BF6": "Bitstream myBitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to fill data of myBitStream\n\nif SAMP_RAKNET_BITSTREAM_EMULATE_AS_INCOMING_RPC {id} SampRpc.ScrClearAnimations myBitStream\nthen // RPC In has been emulated successfully\nelse // RPC Data has been rejected by RakNet\nend",
    "0BF7": "Bitstream myBitStream = SAMP_RAKNET_CREATE_BITSTREAM\n// do something to fill data of myBitStream\n\nif SAMP_RAKNET_BITSTREAM_EMULATE_AS_INCOMING_PACKET {id} SampPacket.MarkerSync myBitStream\nthen // Packet In has been emulated successfully\nelse // Packet Data has been rejected by RakNet\nend",
    "0BF8": "// Example: Everytime our client transmits/receives an RPC. We Echo the RPC Name to chat\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nif or\n    not SAMP_RAKNET_HOOK_INCOMING_RPC {callbackLabel} @RPC_In\n    not SAMP_RAKNET_HOOK_OUTCOMING_RPC {callbackLabel} @RPC_Out\nthen TERMINATE_THIS_CUSTOM_SCRIPT\nend\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:RPC_In // all received RPC will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    int packetName\n    if packetName = SAMP_RAKNET_GET_RPC_NAME {id} packetId\n    then SAMP_ADD_MESSAGE_TO_CHAT {format} \"Received RPC: ID=%d , Name=%s\" {color} 0xFF00FFFF {values} packetId packetName\n    else // unknown RPC ID\n    end\nSAMP_RAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to process the data\n\n:RPC_Out // all transmitting RPC will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    int packetName\n    if packetName = SAMP_RAKNET_GET_RPC_NAME {id} packetId\n    then SAMP_ADD_MESSAGE_TO_CHAT {format} \"Transmitting RPC: ID=%d , Name=%s\" {color} 0xFF00FFFF {values} packetId packetName\n    else // unknown RPC ID\n    end\nSAMP_RAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to process the data",
    "0BF9": "// Example: Everytime our client transmits/receives a Packet. We Echo the Packet Name to chat\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\n// wait for SAMP to fully initialize\nREPEAT\n    wait 100\nUNTIL SAMP_IS_AVAILABLE\n\nif or\n    not SAMP_RAKNET_HOOK_INCOMING_PACKET {callbackLabel} @Packet_In\n    not SAMP_RAKNET_HOOK_OUTCOMING_PACKET {callbackLabel} @Packet_Out\nthen TERMINATE_THIS_CUSTOM_SCRIPT\nend\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:Packet_In // all received RPC will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    int packetName\n    if packetName = SAMP_RAKNET_GET_PACKET_NAME {id} packetId\n    then SAMP_ADD_MESSAGE_TO_CHAT {format} \"Received Packet: ID=%d , Name=%s\" {color} 0xFF00FFFF {values} packetId packetName\n    else // unknown Packet ID\n    end\nSAMP_RAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to process the data\n\n:Packet_Out // all transmitting RPC will detour here first\n    int packetId = SAMP_RAKNET_HOOK_GET_PARAM {type} SampRakNetHookParam.PacketId\n    int packetName\n    if packetName = SAMP_RAKNET_GET_PACKET_NAME {id} packetId\n    then SAMP_ADD_MESSAGE_TO_CHAT {format} \"Transmitting Packet: ID=%d , Name=%s\" {color} 0xFF00FFFF {values} packetId packetName\n    else // unknown Packet ID\n    end\nSAMP_RAKNET_HOOK_RETURN {unblockData} true // end this callback and allow RakNet to process the data",
    "0BFA": "int iVal, strBuf\nfloat fVal\niVal = 0x3AB0 // let's call this value as Int_A\nfVal = 13.42 // let's call this value as Float_A\nALLOCATE_MEMORY strBuf {size} 70 // lets call the pointer to this allocated memory as Ptr_A\nSF_PUSH_LOCAL_VARIABLES // trigger our savepoint, we call it SavePoint_A\n// do something to iVal, fVal, strBuf\n\n// let's try to overwrite the values\niVal = 0x98A // let's call this value as Int_B\nfVal = 721.99 // let's call this value as Float_B\nALLOCATE_MEMORY strBuf {size} 14 // lets call the pointer to this allocated memory as Ptr_B\nSF_PUSH_LOCAL_VARIABLES // trigger our savepoint, we call it SavePoint_B\n// do something to iVal, fVal, strBuf\n\n// let's try to overwrite the values, again!\niVal = 0x3FB0A1FF // let's call this value as Int_C\nfVal = 1938.0 // let's call this value as Float_C\nALLOCATE_MEMORY strBuf {size} 400 // lets call the pointer to this allocated memory as Ptr_C\n// do something to iVal, fVal, strBuf\nFREE_MEMORY {address} strBuf // free Ptr_C\n\n// Now let's recover back all the local variables from the previous savepoint\nSF_POP_LOCAL_VARIABLES\n/* expected:\n *     iVal   = Int_B   = 0x98A\n *     fVal   = Float_B = 721.99\n *     strBuf = Ptr_B\n */\nFREE_MEMORY {address} strBuf // free Ptr_B\n\n// Now let's recover back all the local variables again\nSF_POP_LOCAL_VARIABLES\n/* expected:\n *     iVal   = Int_A   = 0x3AB0\n *     fVal   = Float_A = 13.42\n *     strBuf = Ptr_A\n */\nFREE_MEMORY {address} strBuf // free Ptr_A",
    "0BFB": "int iVal, strBuf\nfloat fVal\niVal = 0x3AB0 // let's call this value as Int_A\nfVal = 13.42 // let's call this value as Float_A\nALLOCATE_MEMORY strBuf {size} 70 // lets call the pointer to this allocated memory as Ptr_A\nSF_PUSH_LOCAL_VARIABLES // trigger our savepoint, we call it SavePoint_A\n// do something to iVal, fVal, strBuf\n\n// let's try to overwrite the values\niVal = 0x98A // let's call this value as Int_B\nfVal = 721.99 // let's call this value as Float_B\nALLOCATE_MEMORY strBuf {size} 14 // lets call the pointer to this allocated memory as Ptr_B\nSF_PUSH_LOCAL_VARIABLES // trigger our savepoint, we call it SavePoint_B\n// do something to iVal, fVal, strBuf\n\n// let's try to overwrite the values, again!\niVal = 0x3FB0A1FF // let's call this value as Int_C\nfVal = 1938.0 // let's call this value as Float_C\nALLOCATE_MEMORY strBuf {size} 400 // lets call the pointer to this allocated memory as Ptr_C\n// do something to iVal, fVal, strBuf\nFREE_MEMORY {address} strBuf // free Ptr_C\n\n// Now let's recover back all the local variables from the previous savepoint\nSF_POP_LOCAL_VARIABLES\n/* expected:\n *     iVal   = Int_B   = 0x98A\n *     fVal   = Float_B = 721.99\n *     strBuf = Ptr_B\n */\nFREE_MEMORY {address} strBuf // free Ptr_B\n\n// Now let's recover back all the local variables again\nSF_POP_LOCAL_VARIABLES\n/* expected:\n *     iVal   = Int_A   = 0x3AB0\n *     fVal   = Float_A = 13.42\n *     strBuf = Ptr_A\n */\nFREE_MEMORY {address} strBuf // free Ptr_A",
    "0BFC": "// Example: Script Intercommunication\n// Allowed two or more scripts to communicate to each other using Custom Global Variables\n\n// at script1.cs\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nconst\n    STRMSG = \"Hello Script2 How are you?\"\n    PASSEDINT = 0xFA2AD\n    PASSEDFLOAT = 444.23\nend\n\nint strBuf = ALLOCATE_MEMORY {size} 415\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myBufGVar\" {value} strBuf\nSTRING_FORMAT {buffer} strBuf {format} STRMSG\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\" {value} PASSEDINT\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\" {value} PASSEDFLOAT\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"S1S2ready\" {value} true // tell script 2 that the data is ready\n\nwhile true\n    wait 0\n    bool readAvailable\n    if readAvailable = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"S2S1ready\" // script 2 is telling us to read his data\n    then\n        if readAvailable == true\n        then\n            bool getInt = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\"\n            bool getFloat = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\"\n            print_formatted_now \"Received:~n~Int=%d , Float=%f~n~Msg=%s\" 2000 getInt getFloat strBuf\n            wait 4000 // give time for the print to disappear so that it will not overwrite newly printed text\n            STRING_FORMAT {buffer} strBuf {format} STRMSG\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\" {value} PASSEDINT\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\" {value} PASSEDFLOAT\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"S1S2ready\" {value} true // tell script 2 that the data is ready\n        end\n    end\nend\n\n// at script2.cs\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nconst\n    STRMSG = \"I'm Good Script1 Thanks for asking!\"\n    PASSEDINT = 0x14AC00\n    PASSEDFLOAT = 1923.44\nend\n\nwhile true\n    wait 0\n    bool readAvailable\n    if readAvailable = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"S1S2ready\" // script 2 is telling us to read his data\n    then\n        if readAvailable == true\n        then\n            bool getInt = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\"\n            bool getFloat = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\"\n            print_formatted_now \"Received:~n~Int=%d , Float=%f~n~Msg=%s\" 2000 getInt getFloat strBuf\n            wait 4000 // give time for the print to disappear so that it will not overwrite newly printed text\n            STRING_FORMAT {buffer} strBuf {format} STRMSG\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\" {value} PASSEDINT\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\" {value} PASSEDFLOAT\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"S2S1ready\" {value} true // tell script 1 that the data is ready\n        end\n    end\nend",
    "0BFD": "// Example: Script Intercommunication\n// Allowed two or more scripts to communicate to each other using Custom Global Variables\n\n// at script1.cs\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nconst\n    STRMSG = \"Hello Script2 How are you?\"\n    PASSEDINT = 0xFA2AD\n    PASSEDFLOAT = 444.23\nend\n\nint strBuf = ALLOCATE_MEMORY {size} 415\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myBufGVar\" {value} strBuf\nSTRING_FORMAT {buffer} strBuf {format} STRMSG\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\" {value} PASSEDINT\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\" {value} PASSEDFLOAT\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"S1S2ready\" {value} true // tell script 2 that the data is ready\n\nwhile true\n    wait 0\n    bool readAvailable\n    if readAvailable = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"S2S1ready\" // script 2 is telling us to read his data\n    then\n        if readAvailable == true\n        then\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"S2S1ready\" {value} false // clear flag\n            bool getInt = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\"\n            bool getFloat = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\"\n            print_formatted_now \"Received:~n~Int=%d , Float=%f~n~Msg=%s\" 2000 getInt getFloat strBuf\n            wait 4000 // give time for the print to disappear so that it will not overwrite newly printed text\n            STRING_FORMAT {buffer} strBuf {format} STRMSG\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\" {value} PASSEDINT\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\" {value} PASSEDFLOAT\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"S1S2ready\" {value} true // tell script 2 that the data is ready\n        end\n    end\nend\n\n// at script2.cs\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nconst\n    STRMSG = \"I'm Good Script1 Thanks for asking!\"\n    PASSEDINT = 0x14AC00\n    PASSEDFLOAT = 1923.44\nend\n\nwhile true\n    wait 0\n    bool readAvailable\n    if readAvailable = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"S1S2ready\" // script 2 is telling us to read his data\n    then\n        if readAvailable == true\n        then\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"S1S2ready\" {value} false // clear flag\n            bool getInt = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\"\n            bool getFloat = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\"\n            print_formatted_now \"Received:~n~Int=%d , Float=%f~n~Msg=%s\" 2000 getInt getFloat strBuf\n            wait 4000 // give time for the print to disappear so that it will not overwrite newly printed text\n            STRING_FORMAT {buffer} strBuf {format} STRMSG\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myIntGVar\" {value} PASSEDINT\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"myFloatGVar\" {value} PASSEDFLOAT\n            SF_SET_CUSTOM_GLOBAL_VARIABLE {name} \"S2S1ready\" {value} true // tell script 1 that the data is ready\n        end\n    end\nend",
    "0BFE": "int timeStamp = SF_GET_TICK_COUNT\ntimeStamp += 3000 // duration of the wait\nrepeat\n    wait 0\n    // do something\n    int lapseOfTime = SF_GET_TICK_COUNT\n    lapseOfTime -= timeStamp\nuntil lapseOfTime >= 0\n\n// precisely 3 seconds have passed after this block",
    "0BFF": "int colPoint, entity\nif colPoint, entity = SF_PROCESS_LINE_OF_SIGHT {fromCoordX} 1032.0 {fromCoordY} 30.8 {fromCoordZ} 13.3 {toCoordX} 1032.0 {toCoordY} 40.0 {toCoordZ} 40.37 {checkBuildings} true {checkCars} true {checkChars} true {checkObjects} true {checkParticles} true {seeThrough} true {ignoreCameras} true\nthen // do something to colPoint, entity\nelse // no obstacles between the two points\nend",
    "0C00": "int absInt = -97\nabsInt = SF_ABS {number} absInt\n// expected: absInt = 97\n\nfloat absFloat = -3141.04\nabsFloat = SF_ABS {number} absFloat\n// expected: absFloat = 3141.04",
    "0C01": "float pi = 3.1415926535897932384626433832795\nfloat deg = SF_RADIANS_TO_DEGREES {radian} pi\n// expected: deg = 180.0",
    "0C02": "float halfRevolution = 180.0\nfloat rad = SF_DEGREES_TO_RADIANS {degrees} halfRevolution\n// expected: rad = 3.1415926535897932384626433832795",
    "0C03": "float halfPi = 1.5707963267948966192313216916398\nfloat ratio = SF_SIN {radians} halfPi\n// expected: ratio = 1.0",
    "0C04": "float rad = SF_ASIN {ratio} 0.5\n// expected: rad = 0.52359877559829887307710723054658",
    "0C05": "float pi = 3.1415926535897932384626433832795\nfloat ratio = SF_COS {radians} pi\n// expected: ratio = -1.0",
    "0C06": "float rad = SF_ACOS {ratio} 0.5\n// expected: rad = 1.0471975511965977461542144610932",
    "0C07": "float quarterPi = 0.78539816339744830961566084581988\nfloat ratio = SF_TAN {radians} quarterPi\n// expected: ratio = 1.0",
    "0C08": "float rad = SF_ATAN 0.5\n// expected: rad = 0.46364760900080611621425623146121",
    "0C09": "float val = SF_POW {coefficient} 13.0 {exponent} 1.2 // fifth root of 13.0 raised to the sixth power\n// exapected val = 21.713609480352535132447487587065",
    "0C0A": "float val \nval = SF_CEIL {value} 13.3\n// expected: val = 14.0\n\nval = SF_CEIL {value} -27.9\n// expected: val = -27.0",
    "0C0B": "float val \nval = SF_FLOOR {value} 13.9\n// expected: val = 13.0\n\nval = SF_FLOOR {value} -27.3\n// expected: val = -28.0",
    "0C0C": "int myCharPtr = GET_PED_POINTER $scplayer\nfloat damageTaken = SF_READ_MEMORY_WITH_OFFSET {address} myCharPtr {offset} 0xD8 {size} 4\nint damageDealerWeapon = SF_READ_MEMORY_WITH_OFFSET {address} myCharPtr {offset} 0x760 {size} 4\nint damageDealerCharPtr = SF_READ_MEMORY_WITH_OFFSET {address} myCharPtr {offset} 0x764 {size} 4",
    "0C0D": "// Example: Weird Looking Player Character\n// Make our character model look like a messed-up pancake by corrupting the rotation matrix values\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nwhile true\n    wait 500\n    float randVal\n    int myCharPtr = GET_PED_POINTER $scplayer\n    int rotMtxPtr\n    if rotMtxPtr = SF_READ_MEMORY_WITH_OFFSET {address} myCharPtr {offset} 0x14 {size} 4 // pointer to rotation matrix\n    then\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x00 {size} 4 {value} randVal // RotX_OffsetX\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x04 {size} 4 {value} randVal // RotX_OffsetY\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x08 {size} 4 {value} randVal // RotX_OffsetZ\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x0C {size} 4 {value} randVal // RotX_OffsetW\n\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x10 {size} 4 {value} randVal // RotY_OffsetX\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x14 {size} 4 {value} randVal // RotY_OffsetY\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x18 {size} 4 {value} randVal // RotY_OffsetZ\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x1C {size} 4 {value} randVal // RotY_OffsetW\n\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x20 {size} 4 {value} randVal // RotZ_OffsetX\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x24 {size} 4 {value} randVal // RotZ_OffsetY\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x28 {size} 4 {value} randVal // RotZ_OffsetZ\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_MEMORY_WITH_OFFSET {address} rotMtxPtr {offset} 0x2C {size} 4 {value} randVal // RotZ_OffsetW\n    end\nend",
    "0C0E": "// Example: Read the rotation matrix values\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nwhile true\n    wait 500\n    float randVal\n    int myCharPtr = GET_PED_POINTER $scplayer\n    int rotMtxPtr\n    if rotMtxPtr = SF_READ_MEMORY_WITH_OFFSET {address} myCharPtr {offset} 0x14 {size} 4 // pointer to rotation matrix\n    then\n        float rotX_OffsetX = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 0\n        float rotX_OffsetY = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 1\n        float rotX_OffsetZ = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 2\n        float rotX_OffsetW = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 3\n\n        float rotY_OffsetX = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 4\n        float rotY_OffsetY = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 5\n        float rotY_OffsetZ = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 6\n        float rotY_OffsetW = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 7\n\n        float rotZ_OffsetX = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 8\n        float rotZ_OffsetY = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 9\n        float rotZ_OffsetZ = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 10\n        float rotZ_OffsetW = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 11\n    end\nend",
    "0C0F": "// Example: Weird Looking Player Character\n// Make our character model look like a messed-up pancake by corrupting the rotation matrix values\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nwhile true\n    wait 500\n    float randVal\n    int myCharPtr = GET_PED_POINTER $scplayer\n    int rotMtxPtr\n    if rotMtxPtr = SF_READ_MEMORY_WITH_OFFSET {address} myCharPtr {offset} 0x14 {size} 4 // pointer to rotation matrix\n    then\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 0 {value} randVal // RotX_OffsetX\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 1 {value} randVal // RotX_OffsetY\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 2 {value} randVal // RotX_OffsetZ\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 3 {value} randVal // RotX_OffsetW\n\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 4 {value} randVal // RotY_OffsetX\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 5 {value} randVal // RotY_OffsetY\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 6 {value} randVal // RotY_OffsetZ\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 7 {value} randVal // RotY_OffsetW\n\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 8 {value} randVal // RotZ_OffsetX\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 9 {value} randVal // RotZ_OffsetY\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 10 {value} randVal // RotZ_OffsetZ\n        float randVal = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -1.0 {max} 1.0\n        SF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} rotMtxPtr {elementIndex} 11 {value} randVal // RotZ_OffsetW\n    end\nend",
    "0C10": "// copy the entire struct of our character to a buffer\nint saveBuf = ALLOCATE_MEMORY {size} 0x7C4\nint myCharPtr = GET_PED_POINTER $scplayer\nSF_MEMCPY {destination} saveBuf {source} myCharPtr {size} 0x7C4\n// do something to myCharPtr, saveBuf\n\nFREE_MEMORY {address} saveBuf",
    "0C11": "int buf = ALLOCATE_MEMORY {size} 0x100\nSF_MEMFILL {address} buf {byteValue} 0xFF {size} 0x100 // all bytes of buf are now set to 0xFF\n// do something to buf\n\nFREE_MEMORY {address} saveBuf",
    "0C12": "int buf1 = ALLOCATE_MEMORY {size} 14\nint buf2 = ALLOCATE_MEMORY {size} 14\n\nSF_MEMFILL {address} buf1 {byteValue} 0x00 {size} 14\nSF_MEMFILL {address} buf2 {byteValue} 0x00 {size} 14\nif SF_MEMEQ {addressA} buf1 {addressB} buf2 {size} 14\nthen // expected\nelse // this section will not execute\nend\n\nSF_WRITE_MEMORY_WITH_OFFSET {address} buf1 {offset} 5 {size} 4 {value} 0xFC4A795B\nSF_WRITE_MEMORY_WITH_OFFSET {address} buf2 {offset} 10 {size} 2 {value} 0xABCD\nif SF_MEMEQ {addressA} buf1 {addressB} buf2 {size} 14\nthen // this section will not execute\nelse // expected\nend\n\nFREE_MEMORY {address} buf1\nFREE_MEMORY {address} buf2",
    "0C13": "int strbuf = ALLOCATE_MEMORY {size} 12\nSF_STRCPY {destination} strbuf {source} \"Hello World\"\nPRINT_FORMATTED_NOW {text} strBuf {time} 3000\nFREE_MEMORY {address} strBuf",
    "0C14": "int strbuf1 = ALLOCATE_MEMORY {size} 13\nint strbuf2 = ALLOCATE_MEMORY {size} 13\n\nSF_STRCPY {destination} strbuf1 {source} \"Hello World\"\nSF_STRCPY {destination} strbuf2 {source} \"Hello World\"\nif SF_STREQ {stringA} strBuf1 {stringB} strBuf2\nthen // expected\nelse // this section will not be executed\nend\n\nSF_STRCPY {destination} strbuf2 {source} \"How are you?\"\nif SF_STREQ {stringA} strBuf1 {stringB} strBuf2\nthen // this section will not be executed\nelse // expected\nend\n\nFREE_MEMORY {address} strBuf1\nFREE_MEMORY {address} strBuf2",
    "0C15": "int strbuf = ALLOCATE_MEMORY {size} 12\nSF_STRCPY {destination} strbuf {source} \"Hello\"\nSF_STRCAT {stringBuffer} strbuf {appendedString} \" World\"\nPRINT_FORMATTED_NOW {text} strBuf {time} 3000 // prints \"Hello World\"\nFREE_MEMORY {address} strBuf",
    "0C16": "int strbuf = ALLOCATE_MEMORY {size} 131\nSF_STRCPY {destination} strbuf {source} \"I like playing SASP, But I also like playing SAMP. What should I choose? OK I'll play SASP First! Then I'll player SAMP afterwards\"\n\nint tokenPtr\nif tokenPtr = SF_STRTOK {buffer} strbuf {delimiters} \".,?!\"\nthen\n    PRINT_STRING_NOW strbuf {time} 2000 // prints \"I like playing SASP\"\n    wait 2000\n    repeat\n        // prints the following substrings in series\n        // 1st iteration: \" But I also like playing SAMP\"\n        // 2nd iteration: \" What should I choose\"\n        // 3rd iteration: \" OK I'll play SASP First\"\n        // 4th iteration: \" Then I'll player SAMP afterwards\"\n        PRINT_STRING_NOW tokenPtr {time} 2000\n        wait 2000\n    until not tokenPtr = SF_STRTOK {buffer} tokenPtr {delimiters} \".,?!\"\nend\n\nFREE_MEMORY {address} strBuf",
    "0C17": "int strbuf = ALLOCATE_MEMORY {size} 12\n\nSF_STRCPY {destination} strbuf {source} \"Hello World\"\nint strLen = SF_STRLEN {string}\n// expected: strLen = 11\n\nFREE_MEMORY {address} strBuf",
    "0C18": "int strbuf = ALLOCATE_MEMORY {size} 14\nSF_STRCPY {destination} strbuf {source} \"Are you sure?\"\nPRINT_STRING_NOW {text} strBuf {time} 2000\nwait 2000\nint subStr\nif subStr = SF_STRSTR {source} strbuf {substring} \"you\"\nthen PRINT_STRING_NOW {text} subStr {time} 2000 // prints \"you sure?\"\nelse // this section will not execute\nend\nif subStr = SF_STRSTR {source} strbuf {substring} \"You\"\nthen // this section will not execute\nelse // SF_STRSTR command is case-sensitive. \"you\" != \"You\"\nend\nFREE_MEMORY {address} strBuf",
    "0C19": "int strbuf = ALLOCATE_MEMORY {size} 12\nSF_STRCPY {destination} strbuf {source} \"I'm Human\"\nint charIndex\nif charIndex = SF_STRCSPN {source} strbuf {characterList} \"HiJKl\"\nthen // expected: charIndex = 4\nelse // this section will not execute\nend\nif charIndex = SF_STRCSPN {source} strbuf {characterList} \"hijk\"\nthen // this section will not execute\nelse // characters are not found in strbuf\nend\nFREE_MEMORY {address} strBuf",
    "0C1A": "int convertedInt = SF_ATOI {ascii} \"1423\"\n// expected: convertedInt = 1423",
    "0C1B": "float convertedFloat = SF_ATOF {ascii} \"823.423\"\n// expected: convertedFloat = 823.423",
    "0C1C": "int strBuf = ALLOCATE_MEMORY {size} 33 // max binary length is 32 + null terminator\n\nconst TESTINT = 41534\n\nstrBuf = SF_ITOA {integer} TESTINT {radix} 2 // binary\n// expected strBuf = \"1010001000111110\"\n\nstrBuf = SF_ITOA {integer} TESTINT {radix} 8 // octal\n// expected strBuf = \"121076\"\n\nstrBuf = SF_ITOA {integer} TESTINT {radix} 10 // decimal\n// expected strBuf = \"41534\"\n\nstrBuf = SF_ITOA {integer} TESTINT {radix} 16 // hex\n// expected strBuf = \"A23E\"\n\nFREE_MEMORY {address} strBuf",
    "0C1D": "int arrayOfShort = ALLOCATE_MEMORY {size} 20\n// do something to fill data of arrayOfShort\n\nint shortVal = SF_READ_ELEMENT_OF_SIZED_ARRAY {array} arrayOfShort {index} 3 {size} 2 // reads at Pointer arrayOfShort + 6\n\nFREE_MEMORY {address} arrayOfShort",
    "0C1E": "int arrayOfShort = ALLOCATE_MEMORY {size} 20\nSF_WRITE_ELEMENT_OF_SIZED_ARRAY {array} arrayOfShort {index} 3 {size} 2 {value} 0xFC32 // writes 0xFC32 at Pointer arrayOfShort + 6\n// do something to arrayOfShort\n\nFREE_MEMORY {address} arrayOfShort",
    "0C1F": "const\n    SIZEPERBUFFER = 46\n    ELEMENTSCOUNT = 10\nend\nint bufSize = SIZEPERBUFFER * ELEMENTSCOUNT\nint arrOfBufs = ALLOCATE_MEMORY {size} bufSize\n\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 0 {size} SIZEPERBUFFER {string} \"Script: Hello World!\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 1 {size} SIZEPERBUFFER {string} \"Script: How are you?\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 2 {size} SIZEPERBUFFER {string} \"World: I'm a big ball of mess\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 3 {size} SIZEPERBUFFER {string} \"World: How about you?\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 4 {size} SIZEPERBUFFER {string} \"Script: That's sad to hear\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 5 {size} SIZEPERBUFFER {string} \"Script: But I'm Fine, thanks for asking!\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 6 {size} SIZEPERBUFFER {string} \"World: That's good to Hear!\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 7 {size} SIZEPERBUFFER {string} \"Are you ready to join the mess in this world?\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 8 {size} SIZEPERBUFFER {string} \"Script: Heck Yea! Let's do this!\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 9 {size} SIZEPERBUFFER {string} \"World: I'll be watching you\"\n\nint lastIndex = ELEMENTSCOUNT - 1\nfor elIndex = 0 to lastIndex\n    int elPtr = SF_GET_ELEMENT_POINTER_OF_BUFFER_ARRAY {array} arrOfBufs {index} elIndex {size} SIZEPERBUFFER\n    PRINT_STRING_NOW {text} elPtr {time} 2000\n    wait 2000\nend\n\nFREE_MEMORY {address} arrOfBufs",
    "0C20": "const\n    SIZEPERBUFFER = 46\n    ELEMENTSCOUNT = 10\nend\nint bufSize = SIZEPERBUFFER * ELEMENTSCOUNT\nint arrOfBufs = ALLOCATE_MEMORY {size} bufSize\n\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 0 {size} SIZEPERBUFFER {string} \"Script: Hello World!\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 1 {size} SIZEPERBUFFER {string} \"Script: How are you?\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 2 {size} SIZEPERBUFFER {string} \"World: I'm a big ball of mess\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 3 {size} SIZEPERBUFFER {string} \"World: How about you?\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 4 {size} SIZEPERBUFFER {string} \"Script: That's sad to hear\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 5 {size} SIZEPERBUFFER {string} \"Script: But I'm Fine, thanks for asking!\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 6 {size} SIZEPERBUFFER {string} \"World: That's good to Hear!\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 7 {size} SIZEPERBUFFER {string} \"Are you ready to join the mess in this world?\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 8 {size} SIZEPERBUFFER {string} \"Script: Heck Yea! Let's do this!\"\nSF_WRITE_STRING_TO_ELEMENT_OF_BUFFER_ARRAY {array} arrOfBufs {index} 9 {size} SIZEPERBUFFER {string} \"World: I'll be watching you\"\n\nint lastIndex = ELEMENTSCOUNT - 1\nfor elIndex = 0 to lastIndex\n    int elPtr = SF_GET_ELEMENT_POINTER_OF_BUFFER_ARRAY {array} arrOfBufs {index} elIndex {size} SIZEPERBUFFER\n    PRINT_STRING_NOW {text} elPtr {time} 2000\n    wait 2000\nend\n\nFREE_MEMORY {address} arrOfBufs",
    "0C21": "int strbuf1 = ALLOCATE_MEMORY {size} 13\nint strbuf2 = ALLOCATE_MEMORY {size} 13\n\nSF_STRCPY {destination} strbuf1 {source} \"Hello World\"\nSF_STRCPY {destination} strbuf2 {source} \"heLLo WOrld\"\nif SF_STRIEQ {stringA} strBuf1 {stringB} strBuf2\nthen // expected\nelse // this section will not be executed\nend\n\nFREE_MEMORY {address} strBuf1\nFREE_MEMORY {address} strBuf2",
    "0C22": "int binStrBuf = ALLOCATE_MEMORY {size} 33 // 32-bit has a maximum character length of 32 + null terminator\nint hexStrBuf = ALLOCATE_MEMORY {size} 6\n\nSF_STRCPY {destination} binStrBuf {source} \"10010101110101101\"\nif SF_BIN_TO_HEX {binaryString} binStrBuf {stringBuffer} hexStrBuf {bufferSize} 6\nthen // expected: hexStrBuf = \"12BAD\"\nelse // this section will not be executed\nend\n\nSF_STRCPY {destination} binStrBuf {source} \"10101011110011011110111110011000\"\nif SF_BIN_TO_HEX {binaryString} binStrBuf {stringBuffer} hexStrBuf {bufferSize} 6\nthen // this section will not be executed\nelse // allocated memory size for hexStrBuf is not enough to fit resulting hex string. It requires at least 9 bytes\nend",
    "0C23": "int binStrBuf = ALLOCATE_MEMORY {size} 20\nint hexStrBuf = ALLOCATE_MEMORY {size} 9 // 4-Byte Hex has a maximum character length of 8 + null terminator\n\nSF_STRCPY {destination} hexStrBuf {source} \"CB52C\"\nif SF_HEX_TO_BIN {hexString} hexStrBuf {stringBuffer} binStrBuf {bufferSize} 20\nthen // expected: binStrBuf = \"11001011010100101100\"\nelse // this section will not be executed\nend\n\nSF_STRCPY {destination} hexStrBuf {source} \"ABCDEF98\"\nif SF_HEX_TO_BIN {hexString} hexStrBuf {stringBuffer} binStrBuf {bufferSize} 20\nthen // this section will not be executed\nelse // allocated memory size for binStrBuf is insufficient to fit the resulting binary string. It requires at least 33 bytes\nend",
    "0C24": "const BUFSIZE = 15\nint buf = ALLOCATE_MEMORY {size} BUFSIZE\n\nSF_STRNCPY {buffer} buf {source} \"Hello World\" {size} BUFSIZE\n// expected: buf = \"Hello World\"\n\nSF_STRNCPY {buffer} buf {source} \"It's so good to see you again!\" {size} BUFSIZE\n// expected: buf = \"It's so good t\"",
    "0C25": "int strbuf1 = ALLOCATE_MEMORY {size} 13\nint strbuf2 = ALLOCATE_MEMORY {size} 16\n\nSF_STRCPY {destination} strbuf1 {source} \"Hello World?\"\nSF_STRCPY {destination} strbuf2 {source} \"Hello World!\"\nif SF_STRNEQ {stringA} strBuf1 {stringB} strBuf2 {length} 11\nthen // expected\nelse // this section will not be executed\nend\nif SF_STRNEQ {stringA} strBuf1 {stringB} strBuf2 {length} 12\nthen // this section will not be executed\nelse // expected since the last character ofstrBuf1 is different from strBuf2's last character\nend\n\nSF_STRCPY {destination} strbuf1 {source} \"Hello World\"\nSF_STRCPY {destination} strbuf2 {source} \"Hello World :-)\"\nif SF_STRNEQ {stringA} strBuf1 {stringB} strBuf2 {length} 15\nthen // expected since the strBuf1's length is only 11, the specified length of 15 got overridden and the rest of the remaining characters at strBuf2 were ignored\nelse // this section will not be executed\nend\n\nFREE_MEMORY {address} strBuf1\nFREE_MEMORY {address} strBuf2",
    "0C26": "int strbuf = ALLOCATE_MEMORY {size} 17\n\nstrbuf = SF_STRUPR {source} \"2.4GHz Frequency\"\n// expected: strbuf = \"2.4GHZ FREQUENCY\"\n\nFREE_MEMORY {address} strBuf",
    "0C27": "int strbuf = ALLOCATE_MEMORY {size} 12\n\nSF_STRNCPY {buffer} strbuf {source} \"Hello\" {bufferSize} 12\nSF_STRNCAT {stringBuffer} strbuf {appendedString} \" World\" {bufferSize} 12\nPRINT_FORMATTED_NOW {text} strBuf {time} 3000 // prints \"Hello World\"\nWAIT 2000\n\nSF_STRNCPY {buffer} strbuf {source} \"Hello\" {bufferSize} 12\nSF_STRNCAT {stringBuffer} strbuf {appendedString} \" San Andreas\" {bufferSize} 12\nPRINT_FORMATTED_NOW {text} strBuf {time} 3000 // prints \"Hello San A\"\nWAIT 2000\n\nFREE_MEMORY {address} strBuf",
    "0C28": "int strbuf = ALLOCATE_MEMORY {size} 14\n\nstrbuf = SF_STRLWR {source} \"My Name is CJ\"\n// expected: strbuf = \"my name is cj\"\n\nFREE_MEMORY {address} strBuf",
    "0C29": "int strbuf = ALLOCATE_MEMORY {size} 14\nSF_STRNCPY {destination} strbuf {source} \"Are You Sure?\" {size} 14\nPRINT_STRING_NOW {text} strBuf {time} 2000\nwait 2000\nint subStr\nif subStr = SF_STRISTR {source} strbuf {substring} \"you\"\nthen PRINT_STRING_NOW {text} subStr {time} 2000 // prints \"You Sure?\"\nelse // this section will not execute\nend\nif subStr = SF_STRISTR {source} strbuf {substring} \"World\"\nthen // this section will not execute\nelse // strbuf does not have a substring \"World\" in it\nend\nFREE_MEMORY {address} strBuf",
    "0C2A": "int strbuf = ALLOCATE_MEMORY {size} 36\nSF_STRNCPY {destination} strbuf {source} \"He sells Sea Shells by the Seashore\" {size} 36\nPRINT_STRING_NOW {text} strBuf {time} 2000\nwait 2000\nint subStr\nif subStr = SF_STRCHR {source} strbuf {character} 's'\nthen // prints \"sells Sea Shells by the Seashore\"\n    PRINT_STRING_NOW {text} subStr {time} 2000\n    wait 2000\nelse // this section will not execute\nend\nif subStr = SF_STRCHR {source} strbuf {character} 'S'\nthen // prints \"Sea Shells by the Seashore\"\n    PRINT_STRING_NOW {text} subStr {time} 2000\n    wait 2000\nelse // this section will not execute\nend\nif subStr = SF_STRCHR {source} strbuf {substring} 'Y'\nthen // this section will not execute\nelse // SF_STRCHR command is case-sensitive. 'y' != 'Y'\nend\nFREE_MEMORY {address} strBuf",
    "0C2B": "int strbuf = ALLOCATE_MEMORY {size} 36\nSF_STRNCPY {destination} strbuf {source} \"Are you sure? Are You REALLY Sure!?\" {size} 14\nPRINT_STRING_NOW {text} strBuf {time} 2000 // prints \"Are you sure? Are You REALLY Sure!?\"\nwait 2000\nint subStr = strBuf\nwhile subStr = SF_STRPBRK {source} subStr {characterList} \"SsYy\"\n    /* Print the following in series\n     * 1st Iteration: \"you sure? Are You REALLY Sure!?\"\n     * 2nd Iteration: \"sure? Are You REALLY Sure!?\"\n     * 3rd Iteration: \"You REALLY Sure!?\"\n     * 4th Iteration: \"Sure!?\"\n     */\n    PRINT_STRING_NOW {text} subStr {time} 2000\n    wait 2000\nend\nPRINT_STRING_NOW {text} strBuf {time} 2000 // prints \"Are you sure? Are You REALLY Sure!?\"\nFREE_MEMORY {address} strBuf",
    "0C2C": "int strbuf = ALLOCATE_MEMORY {size} 36\nSF_STRNCPY {destination} strbuf {source} \"He sells Sea Shells by the Seashore\" {size} 36\nPRINT_STRING_NOW {text} strBuf {time} 2000\nwait 2000\nint subStr\nif subStr = SF_STRRCHR {source} strbuf {character} 's'\nthen\n    PRINT_STRING_NOW {text} subStr {time} 2000 // prints \"shore\"\n    wait 2000\nelse // this section will not execute\nend\nif subStr = SF_STRRCHR {source} strbuf {character} 'S'\nthen\n    PRINT_STRING_NOW {text} subStr {time} 2000 // prints \"Seashore\"\n    wait 2000\nelse // this section will not execute\nend\nif subStr = SF_STRRCHR {source} strbuf {substring} 'Y'\nthen // this section will not execute\nelse // SF_STRRCHR command is case-sensitive. 'y' != 'Y'\nend\nFREE_MEMORY {address} strBuf",
    "0C2D": "int revStrbuf = ALLOCATE_MEMORY {size} 15\nrevStrbuf = SF_STRREV {source} \"Repaid Nametag\"\nPRINT_STRING_NOW {text} revStrbuf {time} 2000 // prints \"gatemaN diapeR\"\nFREE_MEMORY {address} revStrbuf",
    "0C2E": "int strbuf = ALLOCATE_MEMORY {size} 12\nSF_STRCPY {destination} strbuf {source} \"I'm Human\"\nint charIndex\nif charIndex = SF_STRSPN {source} strbuf {characterList} \"hIjkL\"\nthen // expected: charIndex = 1\nelse // this section will not execute\nend\nif charIndex = SF_STRSPN {source} strbuf {characterList} \"' aHImnu\"\nthen // this section will not execute\nelse // all characters at strbuf were in the characterList\nend\nFREE_MEMORY {address} strBuf",
    "0C2F": "int strbuf = ALLOCATE_MEMORY {size} 19\nSF_STRCPY {destination} strbuf {source} \"2324 0x324 MP5 523\"\n\nint unscannedPtr, convertedLong\nunscannedPtr, convertedLong = SF_STRTOL {source} strbuf {radix} 10 // extract decimal integer\n// expected: convertedLong = 2324\nunscannedPtr, convertedLong = SF_STRTOL {source} unscannedPtr {radix} 16 // extract hexadecimal integer\n// expected: convertedLong = 0x324\nunscannedPtr, convertedLong = SF_STRTOL {source} unscannedPtr {radix} 10\n// extraction will failed because a non whitespace non-integer character has been encountered and cannot proceed further,\n// when the scan fails, unscannedPtr remains the same while convertedLong = 0 \n\nFREE_MEMORY {address} strBuf",
    "0C30": "int mxbuf = ALLOCATE_MEMORY {size} 48\nint quatbuf = ALLOCATE_MEMORY {size} 16\n\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 0 {value}  0.2232394 // pitchVectorX\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 1 {value}  0.1799574 // pitchVectorY\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 2 {value}  0.9580081 // pitchVectorZ\n\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 4 {value}  0.8151008 // rollVectorX\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 5 {value}  0.5045292 // rollVectorY\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 6 {value} -0.2847120 // rollVectorZ\n\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 8 {value} -0.5345791 // yawVectorX\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 9 {value}  0.8444321 // yawVectorY\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 10 {value} -0.0340526 // yawVectorZ\n\nquatbuf = SF_MATRIX_TO_QUAT {matrix} mxbuf\nfloat qW = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} quatbuf {elementIndex} 0 // qW = 0.6507142\nfloat qX = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} quatbuf {elementIndex} 1 // qX = 0.4338095\nfloat qY = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} quatbuf {elementIndex} 2 // qY = 0.5734419\nfloat qZ = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} quatbuf {elementIndex} 3 // qZ = 0.2440178\nPRINT_FORMATTED_NOW \"qW=%f qX=%f~n~qY=%f qZ=%f\" 5000 qW qX qY qZ\n\nFREE_MEMORY {address} mxbuf\nFREE_MEMORY {address} quatbuf",
    "0C31": "int mxbuf = ALLOCATE_MEMORY {size} 36\nint quatbuf = ALLOCATE_MEMORY {size} 16\n\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} quatbuf {elementIndex} 0 {value}  0.6507142 // quaternionW\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} quatbuf {elementIndex} 1 {value}  0.4338095 // quaternionX\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} quatbuf {elementIndex} 2 {value}  0.5734419 // quaternionY\nSF_WRITE_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} quatbuf {elementIndex} 3 {value}  0.2440178 // quaternionZ\n\nmxbuf = SF_QUAT_TO_MATRIX {quaternion} quatbuf\nfloat pvX = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 0\nfloat pvY = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 1\nfloat pvZ = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 2\nfloat rvX = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 4\nfloat rvY = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 5\nfloat rvZ = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 6\nfloat yvX = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 8\nfloat yvY = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 9\nfloat yvZ = SF_READ_ELEMENT_OF_4BYTES_ARRAY {arrayAddress} mxbuf {elementIndex} 10\n/* Expected Result:\n *  [pvX pvY pvZ dummy]   [ 0.2232394  0.1799574  0.9580081 irrelevant]\n *  [rvX rvY rvZ dummy] = [ 0.8151008  0.5045292 -0.2847120 irrelevant]\n *  [yvX yvY yvZ dummy]   [-0.5345791  0.8444321 -0.0340526 irrelevant]\n */\nPRINT_FORMATTED_NOW \"%f %f %f~n~%f %f %f~n~%f %f %f\" 5000 pvX pvY pvZ rvX rvY rvZ yvX yvY yvZ\n\nFREE_MEMORY {address} mxbuf\nFREE_MEMORY {address} quatbuf",
    "0C32": "float qW, qX, qY, qZ = SF_AXES_TO_QUAT {pitchVectorX} 0.2232394 {pitchVectorY} 0.1799574 {pitchVectorZ} 0.9580081 {rollVectorX} 0.8151008 {rollVectorY} 0.5045292 {rollVectorZ} -0.2847120 {yawVectorX} -0.5345791 {yawVectorY} 0.8444321 {yawVectorZ} -0.0340526\n// Expected: qW = 0.6507142, qX = 0.4338095, qY = 0.5734419, qZ = 0.2440178\nPRINT_FORMATTED_NOW \"qW=%f qX=%f~n~qY=%f qZ=%f\" 5000 qW qX qY qZ",
    "0C33": "float pvX, pvY, pvZ, rvX, rvY, rvZ, yvX, yvY, yvZ = SF_QUAT_TO_AXES {quaternionW} 0.6507142 {quaternionX} 0.4338095 {quaternionY} 0.5734419 {pitchVectorZ} 0.2440178\n/* Expected Result:\n *  [pvX pvY pvZ]   [ 0.2232394  0.1799574  0.9580081]\n *  [rvX rvY rvZ] = [ 0.8151008  0.5045292 -0.2847120]\n *  [yvX yvY yvZ]   [-0.5345791  0.8444321 -0.0340526]\n */\nPRINT_FORMATTED_NOW \"pvX=%f pvY=%f pvZ=%f~n~rvX=%f rvY=%f rvZ=%f~n~yvX=%f yvY=%f yvZ=%f\" 5000 pvX pvY pvZ rvX rvY rvZ yvX yvY yvZ",
    "0C34": "// Check the snippet of SF_CALL_CUSTOM_GLOBAL_FUNCTION command for a detailed usage example of this command\nSF_REGISTER_CUSTOM_GLOBAL_FUNCTION {name} \"myGFunc\" @MyGFunc",
    "0C35": "// Example: Shared Global Function across scripts with Interlocking Support between Scripts\n\n// ~~~~~~~~~~~~~~~~~~~Script1.cs~~~~~~~~~~~~~~~~~~~\n{$CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nconst\n    SCRIPT_TEXTNAME = \"Script1\"\n    \n    GFUNC_DOARITHMETIC = \"DoArithmetic\"\n    GFUNC_SETMYHPGETMYPOSITION = \"SetMyHPGetMyPosition\"\n\n    GVAR_PRINTMUTEX = \"PrintMutEx\"\nend\n\n// initialize hosted global functions\nif SF_IS_CUSTOM_GLOBAL_FUNCTION_REGISTERED {name} GFUNC_SETMYHPGETMYPOSITION\nthen SF_UNREGISTER_CUSTOM_GLOBAL_FUNCTION {name} GFUNC_SETMYHPGETMYPOSITION\nend\nSF_REGISTER_CUSTOM_GLOBAL_FUNCTION {name} GFUNC_SETMYHPGETMYPOSITION {label} @GlobalFunc_SetMyHPGetMyPosition\n    //\n\nint strScriptName\nSF_STRING_POINTER {var_storeAddressTo} strScriptName {string} SCRIPT_TEXTNAME\n\nwhile true\n    wait 0\n    int printMutEx\n    if and\n        printMutEx = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} GVAR_PRINTMUTEX\n        printMutEx == 0 // Script1's turn to print texts\n    then\n        float randVal1 = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -10.0 {max}  0.0\n        float randVal2 = GENERATE_RANDOM_FLOAT_IN_RANGE {min}   0.0 {max} 10.0\n        float retSum, retDiff, retProduct, retQuotient\n        if SF_CALL_CUSTOM_GLOBAL_FUNCTION {name} GFUNC_DOARITHMETIC {numParams} 2 {value1} randVal1 {value2} randVal2 {retSum} retSum {retDiff} retDiff {retProduct} retProduct {retQuotient} retQuotient\n        then\n            PRINT_FORMATTED_NOW {format} \"%s: GlobalFunc_DoArithmetic~n~value1=%.2f value2=%.2f~n~Sum=%.2f Diff=%.2f~n~Product=%.2f Quotient=%.2f\" {time} 3000 {args} strScriptName randVal1 randVal2 retSum retDiff retProduct retQuotient\n            wait 3000\n        else // name isn't registered globally\n        end\n\n        float retX, retY, retZ\n        if SF_CALL_CUSTOM_GLOBAL_FUNCTION {name} GFUNC_SETMYHPGETMYPOSITION {numParams} 2 {health} 50 {armor} 100 {retCoordX} retX {retCoordY} retY {retCoordZ} retZ\n        then // name is registered globally\n            PRINT_FORMATTED_NOW {format} \"%s: HybridFunc_SetMyHPGetMyPosition~n~x=%.2f y=%.2f z=%.2f\" {time} 3000 {args} strScriptName retX retY retZ\n            wait 3000\n        else // name isn't registered globally\n        end\n\n        SF_SET_CUSTOM_GLOBAL_VARIABLE {name} GVAR_PRINTMUTEX {value} 1 // tell Script2 that Script1 is done printing its texts\n    else // Script2 is currently printing it's texts\n    end\nend\n\n:GlobalFunc_SetMyHPGetMyPosition\nfunction GlobalFunc_SetMyHPGetMyPosition(desiredHealth:int, desiredArmor:int) // input variable definitions\n    float coordX, coordY, coordZ // output variable definitions\n\n    if IS_CHAR_HEALTH_GREATER $scplayer {health} 0 // not IS_CHAR_DEAD {handle} $scplayer\n    then\n        SET_CHAR_HEALTH $scplayer {health} desiredHealth\n        \n        int myArmor = get_char_armour $scplayer\n        int armorDiff = desiredArmor - myArmor\n        if armorDiff < 0\n        then\n            armorDiff *= -1\n            damage_char $scplayer {amount} armorDiff {damageArmour} true\n        else if armorDiff > 0\n        then ADD_ARMOUR_TO_CHAR $scplayer {amount} armorDiff\n        end\n        end\n        \n        coordX, coordY, coordZ = GET_CHAR_COORDINATES $scplayer\n    end\nSF_CUSTOM_GLOBAL_FUNCTION_RETURN {numRet} 3 coordX coordY coordZ\nend // <--- This part will not be reached. End of GlobalFunc_SetMyHPGetMyPosition\n\n// ~~~~~~~~~~~~~~~~~~~Script2.cs~~~~~~~~~~~~~~~~~~~\n{$CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nconst\n    SCRIPT_TEXTNAME = \"Script2\"\n    \n    GFUNC_DOARITHMETIC = \"DoArithmetic\"\n    GFUNC_SETMYHPGETMYPOSITION = \"SetMyHPGetMyPosition\"\n\n    GVAR_PRINTMUTEX = \"PrintMutEx\"\nend\n\n// initialize hosted global functions\nif SF_IS_CUSTOM_GLOBAL_FUNCTION_REGISTERED {name} GFUNC_DOARITHMETIC\nthen SF_UNREGISTER_CUSTOM_GLOBAL_FUNCTION {name} GFUNC_DOARITHMETIC\nend\nSF_REGISTER_CUSTOM_GLOBAL_FUNCTION {name} GFUNC_DOARITHMETIC {label} @GlobalFunc_DoArithmetic\n    //\n\n    // initialize hosted global variables\nSF_SET_CUSTOM_GLOBAL_VARIABLE {name} GVAR_PRINTMUTEX {value} 0\n    //\n\nint strScriptName\nSF_STRING_POINTER {var_storeAddressTo} strScriptName {string} SCRIPT_TEXTNAME\n\nwhile true\n    wait 0\n    int printMutEx\n    if and\n        printMutEx = SF_GET_CUSTOM_GLOBAL_VARIABLE {name} GVAR_PRINTMUTEX\n        printMutEx == 1 // Script2's turn to print texts\n    then\n        float retX, retY, retZ\n        if SF_CALL_CUSTOM_GLOBAL_FUNCTION {name} GFUNC_SETMYHPGETMYPOSITION {numParams} 2 {health} 100 {armor} 50 {retCoordX} retX {retCoordY} retY {retCoordZ} retZ\n        then // name is registered globally\n            PRINT_FORMATTED_NOW {format} \"%s: HybridFunc_SetMyHPGetMyPosition~n~x=%.2f y=%.2f z=%.2f\" {time} 3000 {args} strScriptName retX retY retZ\n            wait 3000\n        else // name isn't registered globally\n        end\n        \n        float randVal1 = GENERATE_RANDOM_FLOAT_IN_RANGE {min}   0.0 {max} 10.0\n        float randVal2 = GENERATE_RANDOM_FLOAT_IN_RANGE {min} -10.0 {max}  0.0\n        float retSum, retDiff, retProduct, retQuotient\n        if SF_CALL_CUSTOM_GLOBAL_FUNCTION {name} GFUNC_DOARITHMETIC {numParams} 2 {value1} randVal1 {value2} randVal2 {retSum} retSum {retDiff} retDiff {retProduct} retProduct {retQuotient} retQuotient\n        then\n            PRINT_FORMATTED_NOW {format} \"%s: GlobalFunc_DoArithmetic~n~value1=%.2f value2=%.2f~n~Sum=%.2f Diff=%.2f~n~Product=%.2f Quotient=%.2f\" {time} 3000 {args} strScriptName randVal1 randVal2 retSum retDiff retProduct retQuotient\n            wait 3000\n        else // name isn't registered globally\n        end\n\n        SF_SET_CUSTOM_GLOBAL_VARIABLE {name} GVAR_PRINTMUTEX {value} 0 // tell Script1 that Script2 is done printing its texts\n    else // Script1 is currently printing it's texts\n    end\nend\n\n:GlobalFunc_DoArithmetic\nfunction GlobalFunc_DoArithmetic(value1:float, value2:float) // input variable definitions\n    float sum, diff, product, quotient // output variable definitions\n    sum = value1\n    sum += value2\n    diff = value1\n    diff -= value2\n    product = value1\n    product *= value2\n    if value2 <> 0.0\n    then\n        quotient = value1\n        quotient /= value2\n    end\nSF_CUSTOM_GLOBAL_FUNCTION_RETURN {numRet} 4 sum diff product quotient\nend // <--- This part will not be reached. End of GlobalFunc_DoArithmetic",
    "0C36": "// Check the snippet of SF_CALL_CUSTOM_GLOBAL_FUNCTION command for a detailed usage example of this command\nSF_CUSTOM_GLOBAL_FUNCTION_RETURN {numRet} 3 {retParams} 0@ 1@ 2@",
    "0C37": "// Check the snippet of SF_CALL_CUSTOM_GLOBAL_FUNCTION command for a detailed usage example of this command\nif SF_IS_CUSTOM_GLOBAL_FUNCTION_REGISTERED {name} \"MyGFunc\"\nthen // MyGFunc is registered\nelse // MyGFunc is not yet registered\nend",
    "0C38": "int threadPtr, funcPtr\nif threadPtr, funcPtr = SF_CUSTOM_GLOBAL_FUNCTION_GET_ORIGIN {name} \"MyGFunc\"\nthen // MyGFunc is registered\n    // do something to threadPtr and funcPtr\nelse // There is no global function registered with name \"MyGFunc\"\nend",
    "0C39": "// Check the snippet of SF_CALL_CUSTOM_GLOBAL_FUNCTION command for a detailed usage example of this command\nSF_UNREGISTER_CUSTOM_GLOBAL_FUNCTION {name} \"MyGFunc\"",
    "0C3A": "int strPtr\nSF_STRING_POINTER {var} strPtr {string} \"Hello World\"\nPRINT_FORMATTED_NOW {format} \"String Constant says:~n~%s\" {time} 2000 {args} strPtr\n/* prints:\nString Constant says:\nHello World\n*/",
    "0C3B": "SF_D3D_BEGIN {objD3D} D3DPT_POINTLIST",
    "0C3C": "SF_D3D_END",
    "0C3D": "SF_D3D_COLOR {color} 0xFF00FFFF",
    "0C3E": "SF_D3D_VERTEX {startVertex} 0 {primitiveCount} 2",
    "0C3F": "SF_D3D_SET_TEXTURE_COORDS {coordX} 500 {coordY} 500",
    "0C40": "SF_D3D_BIND_TEXTURE {textureObjAdress} 0@",
    "0C41": "SF_D3D_TEXTURE_STRUCT {unknown1} 0@ {unknown2} 1@",
    "0C42": "SF_D3D_TEXTURE_SPRITE {unknown1} 0@ {unknown2} 1@",
    "0C43": "int width, height = SF_D3D_GET_TEXTURE_SIZE {textureObjAdress} 0@",
    "0C44": "SF_D3D_SET_RENDER_STATE {primitiveType} 0 {state} false",
    "0C45": "// Example 1: attach a 3D text to our character or car\nint attachedID\nif IS_CHAR_SITTING_IN_ANY_CAR $scplayer\nthen // attach a red 3d text at the top of my car\n    int myCar = STORE_CAR_CHAR_IS_IN_NO_SAVE $scplayer\n    int myCarModel = GET_CAR_MODEL myCar\n    float offsetZ, unused\n    unused, unused, unused, unused, unused, offsetZ = get_model_dimensions {modelId} myCarModel\n    offsetZ += 2.0 // elevate\n    attachedID = SAMP_GET_CAR_ID {handle} myCar\n    SAMP_CREATE_3D_TEXT_WITH_ID {id} 19 {text} \"I'm InCar\" {color} 0xFFFF0000 {coordx} 0.0 {coordy} 0.0 {coordz} offsetZ {visibilityradius} 10.0 {showbehindwalls} true {attachedplayerid} -1 {attachedcarid} attachedID\n    // 3D Text with ID = 19 has been created successfully, overwriting the old 3D text\nelse // attach a purple 3d text at my character's back\n    attachedID = SAMP_GET_PLAYER_ID {handle} $scplayer\n    SAMP_CREATE_3D_TEXT_WITH_ID {id} 19 {text} \"I'm Onfoot\" {color} 0xFFFF00FF {coordx} 0.0 {coordy} -2.0 {coordz} 0.0 {visibilityradius} 10.0 {showbehindwalls} true {attachedplayerid} attachedID {attachedcarid} -1\n    // 3D Text with ID = 19 has been created successfully, overwriting the old 3D text\nend\n\n\n// Example 2: Create a yellow 3D Text at specified world coordinate\nSAMP_CREATE_3D_TEXT_WITH_ID {id} 19 {text} \"Hello World!\" {color} 0xFFFFFF00 {coordx} 1324.14 {coordy} -2032.44 {coordz} 50.13 {visibilityradius} 50.0 {showbehindwalls} false {attachedplayerid} -1 {attachedcarid} -1\n// 3D Text with ID = 19 has been created successfully, overwriting the old 3D text",
    "0C46": "int my3DTextID\nif my3DTextID = SAMP_CREATE_3D_TEXT {text} \"Hello World!\" {color} 0xFFFFFF00 {coordx} 1324.14 {coordy} -2032.44 {coordz} 50.13 {visibilityradius} 50.0 {showbehindwalls} false {attachedplayerid} -1 {attachedcarid} -1\nthen\n    int vText, vColor, vIsWallHack, vPlayerID, vCarID\n    float vCoordX, vCoordY, vCoordZ, vRadius\n    vText, vColor, vCoordX, vCoordY, vCoordZ, vRadius, vIsWallHack, vPlayerID, vCarID = SAMP_GET_3D_TEXT_PARAMS my3DTextID\nend",
    "0C47": "int my3DTextID\nif my3DTextID = SAMP_CREATE_3D_TEXT {text} \"Hello World!\" {color} 0xFFFFFF00 {coordx} 1324.14 {coordy} -2032.44 {coordz} 50.13 {visibilityradius} 50.0 {showbehindwalls} false {attachedplayerid} -1 {attachedcarid} -1\nthen\n    SAMP_SET_3D_TEXT my3DTextID {text} \"How Are you?\"\n    // text projected by my3DTextID is now \"How Are you?\" instead of \"Hello World!\"\nend",
    "0C48": "if SAMP_CREATE_TEXTDRAW {id} 79 {text} {coordX} 2042.44 {coordY} 1044.55\nthen // TextDraw 79 has been modified\nelse // this section will not execute\nend\n\nif SAMP_CREATE_TEXTDRAW {id} 256 {text} {coordX} 2042.44 {coordY} 1044.55\nthen // this section will not execute\nelse // Max textdraw id for 0.3.7 R1 is 255\nend",
    "0C49": "SAMP_SET_TEXTDRAW_BOX {textDrawId} 87 {isVisible} true {color} 0xFFFFFF00 {width} 320.0 {height} 100.0",
    "0C4A": "SAMP_SET_TEXTDRAW_ALIGNMENT {id} 142 {alignment} SampTextDrawAlignment.Center // center align text",
    "0C4B": "SAMP_SET_TEXTDRAW_PROPORTIONALITY {id} 34 {isProportional} false // assure that the text does not look ugly due to stretching-out together with the textbox regarding of any size",
    "0C4C": "SAMP_SET_TEXTDRAW_STYLE {id} 15 {textStyle} 5 // set style of textdraw into model type",
    "0C4D": "SAMP_SET_TEXTDRAW_SHADOW {id} 31 {tickness} 50 {color} 0x3FFF7F00",
    "0C4E": "SAMP_SET_TEXTDRAW_OUTLINE {id} 31 {tickness} 25 {color} 0xFF7FFF00",
    "0C4F": "SAMP_SET_TEXTDRAW_MODEL {textDrawId} 23 {model} #RUSTLER {rotPitch} 45.0 {rotRoll} -45.0 {rotYaw} -135.0 {camZoomRange} 70.0 {primaryColor} 0xFFFF00FF {secondaryColor} 0xFFFFFF00",
    "0C50": "SAMP_SET_TEXTDRAW_TEXT {id} 13 {text} \"This is a TextDraw\"",
    "0C51": "SAMP_SET_TEXTDRAW_COORDS {id} 53 {coordX} 134.23 {coordY} 99.75",
    "0C52": "SAMP_SET_TEXTDRAW_CHARACTER_PROPERTIES {id} 44 {width} 5.0 {height} 10.0 {color} 0xFFFFFFFF",
    "0C53": "int isVis, color\nfloat width, height\nisVis, color, width, height = SAMP_GET_TEXTDRAW_BOX {id} 74",
    "0C54": "int alignment = SAMP_GET_TEXTDRAW_ALIGNMENT {id} 74",
    "0C55": "int isProportional = SAMP_GET_TEXTDRAW_PROPORTIONALITY {id}",
    "0C56": "int style = SAMP_GET_TEXTDRAW_STYLE {id} 75",
    "0C57": "int tickness, color = SAMP_GET_TEXTDRAW_SHADOW {id} 57",
    "0C58": "int tickness, color = SAMP_GET_TEXTDRAW_OUTLINE {id} 57",
    "0C59": "int mdl, pColor, sColor\nfloat pitch, roll, yaw, zoomRange\nmdl, pitch, roll, yaw, zoomRange, pColor, sColor = SAMP_GET_TEXTDRAW_MODEL {id} 44",
    "0C5A": "int strBuf = ALLOCATE_MEMORY {size} 512\n\nif strBuf = SAMP_STORE_TEXTDRAW_TEXT {id} 64\nthen print_string_now {text} strBuf {time} 100\nend\n\nFREE_MEMORY {address} strBuf",
    "0C5B": "float coordX, coordY = SAMP_GET_TEXTDRAW_COORDS {id} 53",
    "0C5C": "float width, height\nint color\nwidth, height, color = SAMP_GET_TEXTDRAW_CHARACTER_PROPERTIES {id} 53",
    "0C5D": "if SAMP_DOES_TEXTDRAW_EXIST {id} 34\nthen // textdraw with id = 34 exists\nelse // textdraw with id = 34 was not yet created\nend",
    "0C5E": "if SAMP_DELETE_TEXTDRAW {44}\nthen // textdraw with id = 44 has now been deleted\nelse // textdraw with id = 44 doesn't exist\nend",
    "0C5F": "if SF_DOES_CUSTOM_GLOBAL_VARIABLE_EXIST \"myGVar\"\nthen // \nelse\nend",
    "0C60": "const GVARNAME = \"myGVar\"\nint slaveScriptPtr1, slaveScriptPtr2, slaveScriptPtr3, slaveScriptPtr4\n// do something to slaveScriptPtr1, slaveScriptPtr2\n\nif SF_SET_CUSTOM_GLOBAL_VARIABLE_SCOPE {gVarName} GVARNAME {threadPtr} slaveScriptPtr1 {canRead} false {canWrite} false\nthen // block read/write attempt from slaveScriptPtr1 \nelse // Global Var GVARNAME isn't created yet\nend\n\nif SF_SET_CUSTOM_GLOBAL_VARIABLE_SCOPE {gVarName} GVARNAME {threadPtr} slaveScriptPtr2 {canRead} false {canWrite} true\nthen // block read attempt from slaveScriptPtr2\nelse // Global Var GVARNAME isn't created yet\nend\n\nif SF_SET_CUSTOM_GLOBAL_VARIABLE_SCOPE {gVarName} GVARNAME {threadPtr} slaveScriptPtr3 {canRead} true {canWrite} false\nthen // block write attempt from slaveScriptPtr3 \nelse // Global Var GVARNAME isn't created yet\nend\n\nif SF_SET_CUSTOM_GLOBAL_VARIABLE_SCOPE {gVarName} GVARNAME {threadPtr} slaveScriptPtr 4 {canRead} true {canWrite} true\nthen // allow read/write attempt from slaveScriptPtr4 \nelse // Global Var GVARNAME isn't created yet\nend",
    "0C61": "int slaveScriptPtr\n// do something to slaveScriptPtr\n\nint slaveCanRead, slaveCanWrite\nif slaveCanRead, slaveCanWrite = SF_GET_CUSTOM_GLOBAL_VARIABLE_SCOPE {gVarName} \"MyGVar\" {threadPtr} slaveScriptPtr\nthen // do something to slaveCanRead, slaveCanWrite\nelse // custom global variable with name \"MyGVar\" doesn't exist yet\nend",
    "0C62": "if SF_EXECUTE_CONSOLE_COMMAND {command} \"givemoney\"\nthen // \"givemoney\" console command has been executed\nelse // \"givemoney\" is not a console command\nend",
    "0C63": "/* Script Example: Set our character's health and armor through console\n    Type /setmycharhp <health> <armor>\n    Example: /setmycharhp 50 75\n*/\n\n{$USE CLEO}\n{$USE SAMPFUNCS}\nNOP\n\nint cmdStr\nsf_string_pointer {var_storeAddressTo} cmdStr {string} \"setmycharhp\"\nif SF_IS_CONSOLE_COMMAND_REGISTERED {command} cmdStr\nthen SF_UNREGISTER_CONSOLE_COMMAND {command} cmdStr\nend\nSF_REGISTER_CONSOLE_COMMAND {command} cmdStr {callback} @ConsoleCallback_SetHP\n\n// We don't need an infinite loop for this example. So we pause the thread to lessen the workload for our processor\nSF_PAUSE_SCRIPT {id} 0 // Pauses the main thread\n// This part of the main thread will not be reached unless the main thread is resumed\n\n:ConsoleCallback_SetHP\n    int cmdParams\n    if cmdParams = SAMP_GET_PARAMS_OF_LAST_TRIGGERED_COMMAND // check if user included parameters after the command keyword\n    then\n        int paramCountCheck, desiredHealth, desiredArmor\n        if paramCountCheck, desiredHealth, desiredArmor = SCAN_STRING {string} cmdParams {format} \"%f %f\"\n        then\n            if paramCountCheck == 2 // 2 parameters were parsed\n            then\n                int myCharStruct = get_ped_pointer {char} $scplayer\n                write_memory_with_offset {address} myCharStruct {offset} 0x540 {size} 4 {value} desiredHealth\n                write_memory_with_offset {address} myCharStruct {offset} 0x548 {size} 4 {value} desiredArmor\n            end\n        end\n    end\nSF_COMMAND_RETURN // end of callback",
    "0C64": "// Check the snippet of the SF_REGISTER_CONSOLE_COMMAND command for example usage of this command\nint cmdParams\nif SF_UNREGISTER_CONSOLE_COMMAND \"killme\"\nthen // \"killme\" console command has now been removed\nelse // \"killme\" isn't a console command\nend",
    "0C65": "{$CLEO}\n{$USE debug}\n{$USE file}\n{$USE SAMPFUNCS}\nnop\n\nconst\n    SBLVER_URL = \"https://raw.githubusercontent.com/sannybuilder/library/refs/heads/master/sa/version.txt\"\n    SBLVER_FILEPATH = \"readSBLVer.txt\"\n    MAPINDEX_SBLVER = 0\n\n    NATVER_URL = \"https://raw.githubusercontent.com/sannybuilder/library/refs/heads/master/sa/native_version.txt\"\n    NATVER_FILEPATH = \"readNativeVer.txt\"\n    MAPINDEX_NATVER = 1\n\n    DLCOUNT = 2\n\n    TMPBUFSIZE = 64\nend\n\nDebugger.Enable()\n\nint map_FilePaths[DLCOUNT]\nSf.StrPtr(map_FilePaths[MAPINDEX_SBLVER],SBLVER_FILEPATH)\nSf.StrPtr(map_FilePaths[MAPINDEX_NATVER],NATVER_FILEPATH)\n\nint map_DLHandles[DLCOUNT]\nmap_DLHandles[MAPINDEX_SBLVER] = SfDownload.File(SBLVER_URL, SBLVER_FILEPATH)\nmap_DLHandles[MAPINDEX_NATVER] = SfDownload.File(NATVER_URL, NATVER_FILEPATH)\n\nfloat map_Versions[DLCOUNT]\nmap_Versions[MAPINDEX_SBLVER] = -1 // intially undefined value\nmap_Versions[MAPINDEX_NATVER] = -1 // intially undefined value\n\nwhile true\n    wait 0\n    int loopIndex\n    int maxIndex = DLCOUNT - 1\n    for loopIndex = 0 to maxIndex\n        if map_DLHandles[loopIndex] >= 1 // download handle defined\n        then\n            int state = SfDownload.GetState(map_DLHandles[loopIndex])\n            if state >= 0 // download object is now on standby\n            then\n                SfDownload.Release(map_DLHandles[loopIndex])\n                map_DLHandles[loopIndex] = 0 // tell our script that the download is done for this loopindex\n                if Fs.DoesFileExist(map_FilePaths[loopIndex])\n                then\n                    if File fileaHandle = File.Open(map_FilePaths[loopIndex], \"rt\")\n                    then\n                        int buffer = Memory.Allocate(TMPBUFSIZE)\n                        if fileaHandle.ReadString(buffer, TMPBUFSIZE)\n                        then\n                            map_Versions[loopIndex] = Sf.AtoF(buffer)\n                            Debugger.Trace(\"Retrieved Version[%u]: %f\", loopIndex, map_Versions[loopIndex])\n                        else Debugger.Trace(\"Failed to read string from %s\", map_FilePaths[loopIndex])\n                        end\n                        \n                        // cleanup\n                        Memory.Free(buffer)\n                        fileaHandle.Close()\n                    else Debugger.Trace(\"Failed to open %s\", map_FilePaths[loopIndex])\n                    end\n                    Fs.DeleteFile(map_FilePaths[loopIndex])\n                else Debugger.Trace(\"Downloaded File not found: %s state: %d\", map_FilePaths[loopIndex],state)\n                end\n            else // map_DLHandles[loopIndex] is still downloading\n            end\n        end\n    end\n\n    if and\n        map_Versions[MAPINDEX_SBLVER] <> -1\n        map_Versions[MAPINDEX_NATVER] <> -1\n    then\n        Debugger.Trace(\"All Download Instances Ended!\")\n        Debugger.Trace(\"SBL Version: %f\", map_Versions[MAPINDEX_SBLVER])\n        Debugger.Trace(\"Native Version: %f\", map_Versions[MAPINDEX_NATVER])\n        break\n    end\nend\n\nDebugger.Disable()\nterminate_this_custom_script",
    "0C66": "// Check the snippet of SF_DOWNLOAD_FILE for a detailed usage example of this command\n\nSfDownload myDLObj\n// do something to myDLObj\n\nint state\nif state = SF_GET_DOWNLOAD_STATE myDLObj\nthen // do something to state\nelse // myDLObj is not a valid Object Handle\nend",
    "0C67": "int strBuf = ALLOCATE_MEMORY {size} 200\nSF_STORE_OS_ENVIRONMENT_VARIABLE {varName} \"HOMEPATH\" {stringBuffer} buf {buffersize} 200",
    "0C68": "int unicodeStrBuf = ALLOCATE_MEMORY {size} 101\n// do something to unicodeStrBuf\n\nint ansiStrBuf = ALLOCATE_MEMORY {size} 51\nif SF_UNICODE_TO_ANSI {unicodeString} unicodeStrBuf {ansiStringBuffer} ansiStrBuf {bufferSize} 51\nthen print_string_now {text} ansiStrBuf {time} 5000\nelse // Failed Retrieving the ANSI version of the Unicode String\nend\n\nFREE_MEMORY {address} unicodeStrBuf\nFREE_MEMORY {address} ansiStrBuf",
    "0C69": "int ansiStrBuf = ALLOCATE_MEMORY {size} 51\n// do something to ansiStrBuf\n\nint unicodeStrBuf = ALLOCATE_MEMORY {size} 101\nif SF_ANSI_TO_UNICODE {ansiString} ansiStrBuf {unicodeStringBuffer} unicodeStrBuf {bufferSize} 101\nthen do something to unicodeStrBuf\nelse // Failed Retrieving the Unicode version of the ANSI String\nend\n\nFREE_MEMORY {address} unicodeStrBuf\nFREE_MEMORY {address} ansiStrBuf",
    "0C6A": "/* Check the snippets of the following commands for example usage of this command\n* SF_RESTART_SCRIPT\n* SF_TERMINATE_SCRIPT\n*/\n\n// Run a separate asynchronous task that prints something.\n{$CLEO}\n{$USE SAMPFUNCS}\n{$USE debug}\nNOP\n\nSF_START_NEW_SCRIPT_FROM_LABEL {scriptLabel} @AsyncTask {newScriptPtrTo} 0 {passedValues} 321 19.33 // create another task that separately runs from this script in an asynchronous manner\n\nwhile true\n    wait 0\n    // do something asynchronously\nend\n\n:AsyncTask\nfunction AsyncTask(testIntegerValue:int, testFloatValue:float) // variable definitions of our asynchronous task\n // start of the AsyncTask's body\n // no need to specify the \"NOP\" command\n    Debugger.Enable() // debugger will only work inside the AsyncTask's scope. The main script is unaffected\n    Debugger.Trace(\"EmbeddedScript has been Started.\")\n    wait 3000\n    Debugger.Trace(\"Self Terminate\")\n    Debugger.Disable()\n    \n    terminate_this_script // terminate this task\nend // end of the AsyncTask's body (will not be reached, and MUST NOT BE REACHED in any way)",
    "0C6B": "int srcPtr\n// do something to store the pointer to our target custom script's binary data\n\nSfScript csPtr\nSF_START_NEW_SCRIPT_FROM_POINTER {sourcePtr} srcPtr {newScriptPtrTo} csPtr {args}",
    "0C6C": "SfScript scPtr\n// do something to store the target script ptr to scPtr\n\nSF_SET_SCRIPT_LOCAL_VARIABLE scPtr {varIndex}  5 {value} 14.33   // set script scPtr's  5@ = 14.33 (float)\nSF_SET_SCRIPT_LOCAL_VARIABLE scPtr {varIndex} 14 {value} 50      // set script scPtr's 14@ = 50 (decimal int)\nSF_SET_SCRIPT_LOCAL_VARIABLE scPtr {varIndex}  7 {value} 0x85374 // set script scPtr's 7@ = 0x85374 (hex int)\nSF_SET_SCRIPT_LOCAL_VARIABLE scPtr {varIndex} 31 {value} scPtr   // set script scPtr's 31@ = pointer to itself",
    "0C6D": "SfScript scPtr\n// do something to store the target script ptr to scPtr\n\nfloat fVal = SF_GET_SCRIPT_LOCAL_VARIABLE scPtr {varIndex}  5 // get value of script scPtr's  5@\nint   iVal = SF_GET_SCRIPT_LOCAL_VARIABLE scPtr {varIndex} 14 // get value of script scPtr's 14@",
    "0C6E": "// Run an embedded script that prints something. Then terminate it after 5 seconds\n{$CLEO}\n{$USE SAMPFUNCS}\n{$USE debug}\nNOP\n\nDebugger.Enable()\n\nSfScript csPtr\nSfScript.RunFromLabel(@EmbeddedScript, csPtr, 321, 19.33) // csPtr now holds the Pointer to the newly created Custom Script\n\nwait 5000 // blocking wait representing workload\n\ncsPtr.Terminate()\nDebugger.Trace(\"EmbeddedScript has been Terminated.\")\n\nDebugger.Disable()\nTERMINATE_THIS_CUSTOM_SCRIPT\n\n:EmbeddedScript\nfunction EmbeddedScript(testIntegerValue:int, testFloatValue:float) // variable definitions of our asynchronous embedded script\n // start of the EmbeddedScript's body\n // no need to specify the \"NOP\" command\n    Debugger.Enable() // since this custom script is executing independintly from our main script, we need to enable the debugger for this independent custom script\n    \n    Debugger.Trace(\"EmbeddedScript has been Started.\")\n    while true\n        wait 0\n        PRINT_FORMATTED_NOW {text} \"Hello World %d %f\" {time} 100 {args} testIntegerValue testFloatValue\n    end\nend // end of the EmbeddedScript's body",
    "0C6F": "// Run an embedded script that prints incrementing values. Then restart this embedded script, resetting the incremented values to the specified passedValues\n{$CLEO}\n{$USE SAMPFUNCS}\n{$USE debug}\nNOP\n\nDebugger.Enable()\n\nSfScript csPtr\nSfScript.RunFromLabel(@EmbeddedScript, csPtr, 0, 0.0) // csPtr now holds the Pointer to the newly created Custom Script\n\nwhile true\n    wait 5000\n    Debugger.Trace(\"Restarting EmbeddedScript\")\n    csPtr.Restart(5, 10.0) // restarts the EmbeddedScript, setting new initial values\nend\n\n:EmbeddedScript // start of the EmbeddedScript's body\nfunction EmbeddedScript(testIntegerValue:int, testFloatValue:float) // variable definitions of our asynchronous embedded script\n    Debugger.Enable() // since this custom script is executing independintly from our main script, we need to enable the debugger for this independent custom script\n    \n    Debugger.Trace(\"EmbeddedScript has been Started.\") // this message will be our indication that this embeddedscript restarted\n    \n    while true\n        wait 0\n        PRINT_FORMATTED_NOW {text} \"Values: %d %f\" {time} 100 {args} testIntegerValue testFloatValue\n        testIntegerValue++\n        testFloatValue += 0.25\n    end\nend // end of the EmbeddedScript's body",
    "0C70": "int modulePtr\n\nif modulePtr = SF_GET_LOADED_MODULE {module} \"Crypt32.dll\"\nthen // do something to modulePtr\nelse // Crypt32.dll is not yet loaded\nend\n\nif modulePtr = SF_GET_LOADED_MODULE {module} \"Shlwapi.lib\"\nthen // do something to modulePtr\nelse // Shlwapi.lib is not yet loaded\nend\n\nif modulePtr = SF_GET_LOADED_MODULE {module} \"MyCustomFuncs.bin\"\nthen // do something to modulePtr\nelse // MyCustomFuncs.bin is not yet loaded\nend",
    "0C71": "int moduleHandle, procPtr\n\nif moduleHandle = SF_GET_LOADED_MODULE {module} \"MyFuncs.dll\"\nthen\n    if procPtr = SF_GET_MODULE_PROCEDURE {moduleHandle} moduleHandle {functionName} \"MyProc\"\n    then // do something to procPtr\n    else // MyFuncs.dll has no function with name MyProc\n    end\nelse // MyFuncs.dll is not yet loaded\nend\n\nif moduleHandle = SF_GET_LOADED_MODULE {module} \"Crypt32.dll\"\nthen\n    if procPtr = SF_GET_MODULE_PROCEDURE {moduleHandle} moduleHandle {functionName} \"CryptProtectData\"\n    then // do something to procPtr\n    else // this section will not execute since Crypt32.dll has CryptProtectData function\n    end\nelse // Crypt32.dll is not yet loaded\nend",
    "0C72": "// Virtually type \"jumpjet\" cheat as keystroke\n\nTIMERA = 0\nrepeat\n    SF_SET_KEY_STATUS {keyCode} KeyCode.J {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_KEY_STATUS {keyCode} KeyCode.J {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_KEY_STATUS {keyCode} KeyCode.U {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_KEY_STATUS {keyCode} KeyCode.U {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_KEY_STATUS {keyCode} KeyCode.M {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_KEY_STATUS {keyCode} KeyCode.M {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_KEY_STATUS {keyCode} KeyCode.P {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_KEY_STATUS {keyCode} KeyCode.P {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_KEY_STATUS {keyCode} KeyCode.J {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_KEY_STATUS {keyCode} KeyCode.J {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_KEY_STATUS {keyCode} KeyCode.E {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_KEY_STATUS {keyCode} KeyCode.E {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_KEY_STATUS {keyCode} KeyCode.T {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_KEY_STATUS {keyCode} KeyCode.T {isPressed} false",
    "0C73": "// Virtually type \"jumpjet\" cheat as keystroke\n\nTIMERA = 0\nrepeat\n    SF_SET_CHARACTER_KEY_STATUS {ascii} 'j' {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_CHARACTER_KEY_STATUS {ascii} 'j' {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_CHARACTER_KEY_STATUS {ascii} 'u' {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_CHARACTER_KEY_STATUS {ascii} 'u' {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_CHARACTER_KEY_STATUS {ascii} 'm' {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_CHARACTER_KEY_STATUS {ascii} 'm' {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_CHARACTER_KEY_STATUS {ascii} 'p' {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_CHARACTER_KEY_STATUS {ascii} 'p' {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_CHARACTER_KEY_STATUS {ascii} 'j' {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_CHARACTER_KEY_STATUS {ascii} 'j' {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_CHARACTER_KEY_STATUS {ascii} 'e' {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_CHARACTER_KEY_STATUS {ascii} 'e' {isPressed} false\n\nTIMERA = 0\nrepeat\n    SF_SET_CHARACTER_KEY_STATUS {ascii} 't' {isPressed} true\n    wait 0\nuntil TIMERA > 100\nSF_SET_CHARACTER_KEY_STATUS {ascii} 't' {isPressed} false",
    "0C74": "// This example demonstrates the entire SfTimer Class usage\n{$CLEO}\n{$USE SAMPFUNCS}\n{$USE debug}\n{$USE bitwise}\nNOP\n\nDebugger.Enable()\n\n    // initialize variables\nint unrefIterations = 0\nint refIterations = 0\n    //\n\n    // initialize SfTimers\nSfTimer enablerTimerObj = 0 // 0 = undefined SfTimer, to be used later\nif not SfTimer.Create(2000, @UnreferencedTimerCallback_DoSomething, 0) // don't retrieve the SfTimer handle, let's call it \"UnrefTimer\"\nthen Debugger.Trace(\"Failed to Create Unreferenced SfTimer\")\nend\nSfTimer myTimerObj\nif not myTimerObj = SfTimer.Create(5000, @ReferencedTimerCallback_DoSomething) // myTimerObj now contains the handle of this newly created SfTimer\nthen\n    myTimerObj = 0 // 0 = undefined SfTimer\n    Debugger.Trace(\"Failed to Create myTimerObj\")\nend\n    //\n\nwhile true\n    wait 0\n    int isActive\n    if myTimerObj.IsActive()\n    then isActive = true\n    else isActive = false\n    end\n    int interval = myTimerObj.GetInterval()\n    int elapsedTime = myTimerObj.GetElapsedTime()\n    int timeLeft = myTimerObj.GetTimeLeft()\n    Text.PrintFormattedNow(\"isActive=%d interval=%d~n~elapsedTime=%d timeLeft=%d\", 100, isActive, interval, elapsedTime, timeLeft)\nend\n\n:ReferencedTimerCallback_Enabler\n    Debugger.Trace(\"myTimerObj resumed\")\n    if enablerTimerObj <> 0 // SfTimer is defined\n    then\n        if not enablerTimerObj.Delete() // delete this temporary oneshot timer\n        then Debugger.Trace(\"Failed to Delete enablerTimerObj\")\n        end\n    else Debugger.Trace(\"myTimerObj is Undefined\")\n    end\n    enablerTimerObj = 0 // 0 = undefined SfTimer\n    int newInterval = Math.RandomIntInRange(4000, 7000)\n    myTimerObj.Reset() // the timeStamp variable sometimes overshootof reset myTimerObj's interval\n    myTimerObj.SetInterval(newInterval) // update myTimerObj's interval\n    myTimerObj.Reset() // reset myTimerObj's interval again\n    if not myTimerObj.SetStatus(true) // resume myTimerObj\n    then Debugger.Trace(\"Failed to Resume myTimerObj\")\n    end\nSf.CmdRet() // end of callback\n\n:ReferencedTimerCallback_DoSomething\n    refIterations++\n    Debugger.Trace(\"Callback of myTimerObj with ID %X triggered %u times\", myTimerObj, refIterations)\n    int isResumed = refIterations % 5\n    if isResumed == false\n    then\n        if not myTimerObj.SetStatus(false) // pause myTimerObj\n        then Debugger.Trace(\"Failed to Pause myTimerObj\")\n        end\n        if not enablerTimerObj = SfTimer.Create(7000, @ReferencedTimerCallback_Enabler) // temporarily create a oneshot timer\n        then\n            myTimerObj = 0 // 0 = undefined SfTimer\n            Debugger.Trace(\"Failed to Create enablerTimerObj\")\n        end\n        Debugger.Trace(\"myTimerObj Paused for 7 seconds\")\n    end\nSf.CmdRet() // end of callback\n\n:UnreferencedTimerCallback_DoSomething\n    unrefIterations++\n    Debugger.Trace(\"UnrefTimer's Callback triggered %u times\", unrefIterations)\nSf.CmdRet() // end of callback",
    "0C75": "// Check the snippet of SF_CREATE_TIMER for example usage of this command\nsf_delete_timer [SfTimer]",
    "0C76": "// Check the snippet of SF_CREATE_TIMER for example usage of this command\nsf_reset_timer [SfTimer]",
    "0C77": "// Check the snippet of SF_CREATE_TIMER for example usage of this command\nsf_set_timer_interval [SfTimer] {interval} [int]",
    "0C78": "// Check the snippet of SF_CREATE_TIMER for example usage of this command\nsf_set_timer_status [SfTimer] {isActive} [bool]",
    "0C79": "// Check the snippet of SF_CREATE_TIMER for example usage of this command\nif sf_is_timer_active [SfTimer]\nthen // timer is active\nelse // timer is paused\nend",
    "0C7A": "// Check the snippet of SF_CREATE_TIMER for example usage of this command\n[var interval: int] = sf_get_timer_interval [SfTimer]",
    "0C7B": "// Check the snippet of SF_CREATE_TIMER for example usage of this command\n[var elapsedTime: int] = sf_get_timer_elapsed_time [SfTimer]",
    "0C7C": "// Check the snippet of SF_CREATE_TIMER for example usage of this command\n[var timeLeft: int] = sf_get_timer_time_left [SfTimer]",
    "0C7D": "// Check the snippet of SF_DOWNLOAD_FILE for a detailed usage example of this command\n\nSfDownload myDLObj\n// do something to myDLObj\n\nint state\nif SF_RELEASE_DOWNLOAD myDLObj\nthen // myDLObj initially existed and has now been freed from memory\nelse // myDLObj is not a valid Object Handle\nend",
    "0C7E": "if SF_IS_CONSOLE_OPEN\nthen // SF console is open\nelse // SF console is hidden\nend",
    "0C7F": "SAMP_SET_LOCAL_CHAT_COMMAND_DESCRIPTION {chatCommand} \"refillhealth\" {decription} \"Sets My Character's Health into 100\"",
    "0C80": "SF_SET_CONSOLE_COMMAND_DESCRIPTION {command} \"refillhp\" \"Sets Health and Armor to 100\"",
    "0C81": "int carID\n// do something to get carID\nSAMP_FORCE_DRIVING_SYNC {id} carID",
    "0C82": "int carID\n// do something to get carID\nSAMP_FORCE_UNOCCUPIED_SYNC {id} carID {seatId} SeatId.FrontRight",
    "0C83": "SAMP_FORCE_ONFOOT_SYNC",
    "0C84": "SAMP_FORCE_AIM_SYNC",
    "0C85": "int trailerID\n// do something to get trailerID\nSAMP_FORCE_TRAILER_SYNC {id} trailerID",
    "0C86": "int carID\n// do something to get carID\nSAMP_FORCE_PASSENGER_SYNC {id} carID {seatId} SeatId.FrontRight",
    "0C87": "SAMP_FORCE_STATS_SYNC",
    "0C88": "SAMP_FORCE_WEAPONS_SYNC",
    "0C89": "if SF_KEY_JUST_PRESSED {keyCode} KeyCode.R\nthen // user initially pressed the 'R' key\nelse\n    // either user isn't pressing the 'R' key\n    // or user is still pressing the 'R' key and hasn't released it yet\nend",
    "0C8A": "int serverMaxID = SAMP_GET_MAX_PLAYER_ID {streamedOnly} false\nint streamedMaxID = SAMP_GET_MAX_PLAYER_ID {streamedOnly} true",
    "0C8B": "int serverMaxPlayers = SAMP_GET_PLAYER_COUNT {streamedOnly} false\nint streamedPlayerCount = SAMP_GET_PLAYER_COUNT {streamedOnly} true",
    "0C8C": "int workBuf = ALLOCATE_MEMORY {size} 1024\n// do something like read a file then store the File Object to workBuf\n\n// at this point, workBuf contains the File Object\nint loadedTexture = SF_D3D_LOAD_TEXTURE_FROM_FILE_IN_MEMORY {buffer} workBuf {bufferSize} 1024\n// workBuf is now overwritten and contains the texture object",
    "0C8D": "sf_write_text_to_clipboard \"Press CTRL+V To see this Message\"",
    "0C8E": "int buf = ALLOCATE_MEMORY {size} 400\nsf_read_data_from_clipboard {buffer} buf {size} 400\n// do something to buf\nFREE_MEMORY {address} buf",
    "0C8F": "SAMP_PROCESS_CHAT_INPUT {text} \"Hello World\" // processed by RakNet Hooks, then sent to server\nSAMP_PROCESS_CHAT_INPUT {text} \"/mycmd\" // processed by SAMP Chat Hooks, then sent to server",
    "0C90": "if SAMP_IS_CHAT_COMMAND_HOOKED \"iseedeadpeople\"\nthen // command is currently hooked by a callback\nelse // command is not yet hooked by a callback\nend",
    "0C91": "if SF_IS_CONSOLE_COMMAND_REGISTERED \"killme\"\nthen // \"killme\" is a command\nelse // \"killme\" isn't a command\nend",
    "0C92": "int cleoVersion = SF_GET_CLEO_LIBRARY_VERSION",
    "1337": "SF_MAKE_SCRIPT_PRIVATE {isPrivate} true"
  },
  "Sphere": {
    "2880": "Sphere s = add_sphere 0 0 0 2.0\nset_sphere_color s 0 255 0"
  },
  "audio": {
    "0AAC": "int snd = load_audio_stream {audioFileName} \"cleo/sound.mp3\"\nset_audio_stream_looped snd {state} true\nset_audio_stream_state snd {action} AudioStreamAction.Play",
    "0AC1": "int snd = load_3d_audio_stream {audioFileName} \"cleo/sound.mp3\"\nset_audio_stream_looped snd {state} true\nset_play_3d_audio_stream_at_char snd {char} $scplayer\nset_audio_stream_state snd {action} AudioStreamAction.Play",
    "2500": "while is_audio_stream_playing 0@\n    wait 0\nend",
    "2501": "set_audio_stream_speed 0@ {speed} 0.25\nfloat duration = get_audio_stream_duration 0@\nprint_formatted_now \"It will take %f seconds to play this sound\" {time} 5000 {args} duration",
    "2503": "set_audio_stream_speed 0@ speed 1.0",
    "2504": "set_audio_stream_volume_with_transition 0@ volume 0.0 time_ms 1000 // fade out",
    "2505": "set_audio_stream_speed_with_transition 0@ {speed} 0.0 {timeMs} 500 // tape slow down and pasue",
    "2506": "set_audio_stream_source_size 0@ radius 50.0 // music inside entire building"
  },
  "bitwise": {
    "0B10": "<%= output1 %> = 2 and 3 // 0b10 and 0b11 = 0b10 (2)",
    "0B11": "<%= output1 %> = 2 or 3 // 0b10 or 0b11 = 0b11 (3)",
    "0B12": "<%= output1 %>= 2 xor 3 // 0b10 xor 0b11 = 0b01 (1)",
    "0B13": "<%= output1 %> = ~5 // 5 is 0b101, inverting all bits makes it 0b11111111111111111111111111111010 (-6)",
    "0B14": "<%= output1 %> = 10 mod 3 // returns 1",
    "0B15": "<%= output1 %> = 16 shr 1 // 0b10000 >> 1 = 0b1000 (8)",
    "0B16": "<%= output1 %> = 16 shl 1 // // 0b10000 << 1 = 0b100000 (32)",
    "0B17": "<%= input1 %> &= <%= input2 %>",
    "0B18": "<%= input1 %> |= <%= input2 %>",
    "0B19": "<%= input1 %> ^= <%= input2 %>",
    "0B1A": "~<%= input1 %>",
    "0B1B": "<%= input1 %> %= <%= input2 %>",
    "0B1C": "<%= input1 %> >>= <%= input2 %>",
    "0B1D": "<%= input1 %> <<= <%= input2 %>",
    "0B1E": "debug_on\nint 0@, 1@, 2@, 3@\n0@ = -42\n1@ = allocate_memory size 4\n\n// byte\nwrite_memory address 1@ size 1 value 0@ vp false\n2@ = read_memory address 1@ size 1 vp false\n3@ = 2@\nsign_extend 3@ from_size 1\ntrace \"1 BYTE: original value: %d, read value: %d, extended sign: %d\" 0@ 2@ 3@\n\n// 2 bytes\nwrite_memory address 1@ size 2 value 0@ vp false\n2@ = read_memory address 1@ size 2 vp false\n3@ = 2@\nsign_extend 3@ from_size 2\ntrace \"2 BYTES: original value: %d, read value: %d, extended sign: %d\" 0@ 2@ 3@\n\n// 3 bytes\nwrite_memory address 1@ size 3 value 0@ vp false\n2@ = read_memory address 1@ size 3 vp false\n3@ = 2@\nsign_extend 3@ from_size 3\ntrace \"3 BYTES: original value: %d, read value: %d, extended sign: %d\" 0@ 2@ 3@\n\n// 4 bytes\nwrite_memory address 1@ size 4 value 0@ vp false\n2@ = read_memory address 1@ size 4 vp false\n3@ = 2@\nsign_extend 3@ from_size 4\ntrace \"4 BYTES: original value: %d, read value: %d, extended sign: %d\" 0@ 2@ 3@"
  },
  "debug": {
    "2100": "debug_on\nbreakpoint // pause game\nbreakpoint false // pause this script\nbreakpoint \"blocking\" // pause game with message\nbreakpoint false \"not blocking\" // pause script with message\nbreakpoint \"Time is: %d\" TIMERA // pause game with formatted message\nbreakpoint false \"Value is: ~g~%d\" 0@ // pause script with formatted message",
    "2101": "debug_on\n\ntrace \"Hello world!\"\n\nwait {time} 1000\ntrace \"Time: %d, ~g~Variable: %d\" TIMERA 0@",
    "2102": "log_to_file \".\\myLog.txt\" {timestamp} true {text} \"Line with timestamp prefix\"\nlog_to_file \".\\myLog.txt\" {timestamp} false {text} \"Now just the line. Timer value is: %d\" {args} TIMERA\n\nlog_to_file \"user:\\myUserLog.txt\" {timestamp} false {text} \"Log file in game saves location!\""
  },
  "default": {
    "0003": "// shakes camera for 5 seconds\nTIMERA = 0\nwhile TIMERA < 5000\n    wait 0\n    shake_cam 50\nend",
    "0004": "<%= input1 %> = <%= input2 %>",
    "0005": "<%= input1 %> = <%= input2 %>",
    "0006": "<%= input1 %> = <%= input2 %>",
    "0007": "<%= input1 %> = <%= input2 %>",
    "0008": "<%= input1 %> += <%= input2 %>",
    "0009": "<%= input1 %> += <%= input2 %>",
    "000A": "<%= input1 %> += <%= input2 %>",
    "000B": "<%= input1 %> += <%= input2 %>",
    "000C": "<%= input1 %> -= <%= input2 %>",
    "000D": "<%= input1 %> -= <%= input2 %>",
    "000E": "<%= input1 %> -= <%= input2 %>",
    "000F": "<%= input1 %> -= <%= input2 %>",
    "0010": "<%= input1 %> *= <%= input2 %>",
    "0011": "<%= input1 %> *= <%= input2 %>",
    "0012": "<%= input1 %> *= <%= input2 %>",
    "0013": "<%= input1 %> *= <%= input2 %>",
    "0014": "<%= input1 %> /= <%= input2 %>",
    "0015": "<%= input1 %> /= <%= input2 %>",
    "0016": "<%= input1 %> /= <%= input2 %>",
    "0017": "<%= input1 %> /= <%= input2 %>",
    "0018": "<%= input1 %> > <%= input2 %>",
    "0019": "<%= input1 %> > <%= input2 %>",
    "001A": "<%= input1 %> > <%= input2 %>",
    "001B": "<%= input1 %> > <%= input2 %>",
    "001C": "<%= input1 %> > <%= input2 %>",
    "001D": "<%= input1 %> > <%= input2 %>",
    "001E": "<%= input1 %> > <%= input2 %>",
    "001F": "<%= input1 %> > <%= input2 %>",
    "0020": "<%= input1 %> > <%= input2 %>",
    "0021": "<%= input1 %> > <%= input2 %>",
    "0022": "<%= input1 %> > <%= input2 %>",
    "0023": "<%= input1 %> > <%= input2 %>",
    "0024": "<%= input1 %> > <%= input2 %>",
    "0025": "<%= input1 %> > <%= input2 %>",
    "0026": "<%= input1 %> > <%= input2 %>",
    "0027": "<%= input1 %> > <%= input2 %>",
    "0028": "<%= input1 %> >= <%= input2 %>",
    "0029": "<%= input1 %> >= <%= input2 %>",
    "002A": "<%= input1 %> >= <%= input2 %>",
    "002B": "<%= input1 %> >= <%= input2 %>",
    "002C": "<%= input1 %> >= <%= input2 %>",
    "002D": "<%= input1 %> >= <%= input2 %>",
    "002E": "<%= input1 %> >= <%= input2 %>",
    "002F": "<%= input1 %> >= <%= input2 %>",
    "0030": "<%= input1 %> >= <%= input2 %>",
    "0031": "<%= input1 %> >= <%= input2 %>",
    "0032": "<%= input1 %> >= <%= input2 %>",
    "0033": "<%= input1 %> >= <%= input2 %>",
    "0034": "<%= input1 %> >= <%= input2 %>",
    "0035": "<%= input1 %> >= <%= input2 %>",
    "0036": "<%= input1 %> >= <%= input2 %>",
    "0037": "<%= input1 %> >= <%= input2 %>",
    "0038": "<%= input1 %> == <%= input2 %>",
    "0039": "<%= input1 %> == <%= input2 %>",
    "003A": "<%= input1 %> == <%= input2 %>",
    "003B": "<%= input1 %> == <%= input2 %>",
    "003C": "<%= input1 %> == <%= input2 %>",
    "0042": "<%= input1 %> == <%= input2 %>",
    "0043": "<%= input1 %> == <%= input2 %>",
    "0044": "<%= input1 %> == <%= input2 %>",
    "0045": "<%= input1 %> == <%= input2 %>",
    "0046": "<%= input1 %> == <%= input2 %>",
    "0058": "<%= input1 %> += <%= input2 %>",
    "0059": "<%= input1 %> += <%= input2 %>",
    "005A": "<%= input1 %> += <%= input2 %>",
    "005B": "<%= input1 %> += <%= input2 %>",
    "005C": "<%= input1 %> += <%= input2 %>",
    "005D": "<%= input1 %> += <%= input2 %>",
    "005E": "<%= input1 %> += <%= input2 %>",
    "005F": "<%= input1 %> += <%= input2 %>",
    "0060": "<%= input1 %> -= <%= input2 %>",
    "0061": "<%= input1 %> -= <%= input2 %>",
    "0062": "<%= input1 %> -= <%= input2 %>",
    "0063": "<%= input1 %> -= <%= input2 %>",
    "0064": "<%= input1 %> -= <%= input2 %>",
    "0065": "<%= input1 %> -= <%= input2 %>",
    "0066": "<%= input1 %> -= <%= input2 %>",
    "0067": "<%= input1 %> -= <%= input2 %>",
    "0068": "<%= input1 %> *= <%= input2 %>",
    "0069": "<%= input1 %> *= <%= input2 %>",
    "006A": "<%= input1 %> *= <%= input2 %>",
    "006B": "<%= input1 %> *= <%= input2 %>",
    "006C": "<%= input1 %> *= <%= input2 %>",
    "006D": "<%= input1 %> *= <%= input2 %>",
    "006E": "<%= input1 %> *= <%= input2 %>",
    "006F": "<%= input1 %> *= <%= input2 %>",
    "0070": "<%= input1 %> /= <%= input2 %>",
    "0071": "<%= input1 %> /= <%= input2 %>",
    "0072": "<%= input1 %> /= <%= input2 %>",
    "0073": "<%= input1 %> /= <%= input2 %>",
    "0074": "<%= input1 %> /= <%= input2 %>",
    "0075": "<%= input1 %> /= <%= input2 %>",
    "0076": "<%= input1 %> /= <%= input2 %>",
    "0077": "<%= input1 %> /= <%= input2 %>",
    "0084": "<%= input1 %> = <%= input2 %>",
    "0085": "<%= input1 %> = <%= input2 %>",
    "0086": "<%= input1 %> = <%= input2 %>",
    "0087": "<%= input1 %> = <%= input2 %>",
    "0088": "<%= input1 %> = <%= input2 %>",
    "0089": "<%= input1 %> = <%= input2 %>",
    "008A": "<%= input1 %> = <%= input2 %>",
    "008B": "<%= input1 %> = <%= input2 %>",
    "009A": "int skin = 40\nrequest_model skin\nload_all_models_now\n\nint woman = create_char {type} PedType.CivFemale {model} skin {xyz} 2479.0 -1660.0 13.0\n\nmark_model_as_no_longer_needed skin",
    "00A5": "// get coordinates in front of the player\nfloat x, y, z\nx, y, z = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 5.0 0.0\n\nrequest_model {modelId} #AMBULAN\nif\n    not has_model_loaded {modelId} #AMBULAN\nthen\n    load_all_models_now\nend\nint carHandle = create_car {modelId} #AMBULAN {pos} x y z\nmark_model_as_no_longer_needed #AMBULAN",
    "00BA": "print_big {key} 'DEAD' {time} 5000 {style} TextStyle.Middle",
    "00C3": "debug_on\nbreakpoint \"testing debug_on opcode\"",
    "00C4": "debug_off\nbreakpoint \"testing debug_off opcode\" // will be ignored",
    "00DD": "if\n    is_char_in_model $scplayer {model} #AMBULAN\nthen\n    print_string_now {text} \"Player in ambulance\" {time} 3000\nend",
    "00E1": "while true\n    wait 0\n    \n    if\n        is_button_pressed {pad} PadId.Pad1 {buttonId} Button.DpadUp // usually \"G\"\n    then\n        print_string_now {text} \"Button is down.\" {time} 1\n    end\nend",
    "00E2": "int state = get_pad_state {pad} PadId.Pad1 {buttonId} Button.LeftStickX // -128 to 128\n\n// as multiplier\nfloat analog =# state\nanalog /= 128.0 // -1.0 to 1.0 range\n\nprint_formatted_now {format} \"state: %d, analog: %f\" {time} 5000 {args} state analog",
    "0107": "int modelId = 910\nrequest_model {modelId} modelId\nload_all_models_now\nint obj = create_object {modelId} modelId {pos} 2490.0 -1666.0 14.0\nmark_model_as_no_longer_needed {modelId} modelId",
    "0109": "const Player=0, Pad1 = 0, DpadUp = 8\nwhile True\n    wait 0\n    if \n        is_button_pressed Pad1 DpadUp // usually \"G\"\n    then\n        add_score Player money 1\n    end\nend",
    "0117": "if\n    is_player_dead $player1\nthen\n    ...\nend",
    "015F": "set_fixed_camera_position {pos} 2490.0 -1660.0 15.0 {upVecOffset} 0.0 0.0 -2.0 // 0,0,1 + 0,0,-2 = 0,0,-1\npoint_camera_at_char {char} $scplayer {mode} CameraMode.Fixed {switchStyle} SwitchType.JumpCut",
    "016A": "// fade to black\ndo_fade {time} 2000 {direction} Fade.Out\nset_player_control $player1 {state} false\n\n// wait for screen to be black\nwhile get_fading_status\n    wait 0\nend\n\n// do something in secret\nset_camera_in_front_of_player\n\n// reveal\nset_player_control $player1 {state} true\ndo_fade {time} 2000 {direction} Fade.In",
    "0175": "while true\n    wait 0\n    get_area_visible store_to interiorId\n    if and\n        is_key_pressed Key_F10\n        interiorId == Outside\n    then\n        while is_key_pressed Key_F10\n            wait 0\n        end\n        request_model #HUSTLER\n        load_all_models_now\n        repeat \n            wait 0\n        until has_model_loaded #HUSTLER\n        get_active_camera_coordinates store_to x y z\n        get_closest_car_node_with_heading x y z store_to nodeX nodeY nodeZ heading\n        clear_area nodeX nodeY nodeZ 3.0 False\n        create_car #HUSTLER nodeX nodeY nodeZ store_to Car\n        set_car_heading Car heading\n        mark_car_as_no_longer_needed Car\n        mark_model_as_no_longer_needed #HUSTLER\n    end\nend",
    "018C": "add_one_off_sound {pos} 0.0 0.0 0.0 {sound_id} ScriptSound.SoundRaceGo\n\n\n\n// sound browser\nint soundId = 1000\nint keyWasDown = false\nwhile true\n    wait 0\n    \n    print_formatted_now \"Sound id: %d~n~Press ~y~<~s~ and ~y~>~s~ to browse,~n~hold ~y~SHIFT~s~ to browse faster.~n~Press ~y~?~s~ to play again.\" {time} 0xFFFFFF {args} soundId\n    \n    // handle browse keys\n    if or\n        is_key_pressed {keyCode} KeyCode.OemComma // <\n        is_key_pressed {keyCode} KeyCode.OemPeriod // >\n    then\n        keyWasDown = true\n        \n        int step\n        if\n            is_key_pressed {keyCode} KeyCode.OemPeriod\n        then\n            step = 1\n        else\n            step = -1\n        end\n        if\n            is_key_pressed {keyCode} KeyCode.Shift\n        then\n            step *= 10\n        end\n        soundId += step\n        \n        // warp around if out of bounds\n        if\n            soundId < 1000\n        then\n            soundId = 1190\n        end\n        if\n            soundId > 1190\n        then\n            soundId = 1000\n        end\n        \n        // wait for key release or timeout\n        while true\n            if and\n                not is_key_pressed {keyCode} KeyCode.OemComma // <\n                not is_key_pressed {keyCode} KeyCode.OemPeriod // >\n            then\n                break // keys released\n            end\n            \n            if\n                TimerA > 30 // auto repeat time in miliseconds\n            then\n                TimerA = 0\n                break\n            end\n            \n            wait 0\n        end\n        \n        continue\n    end\n    \n    // handle play key\n    if \n        is_key_pressed {keyCode} KeyCode.Oem2 // ? key\n    then\n        keyWasDown = true\n        \n        wait 50\n        continue\n    end\n    \n    if\n        keyWasDown == true\n    then\n        float x, y, z\n        x, y, z = get_char_coordinates $scplayer\n        \n        add_one_off_sound {pos} x y z {soundId} soundId\n        \n        keyWasDown = false\n    end\n    \n    // keys are up\n    TimerA = -200 // extra delay before auto repeat activates\nend",
    "01B2": "int modelId = get_weapontype_model {weaponType} WeaponType.Pistol\nrequest_model {modelId} modelId\nload_all_models_now\ngive_weapon_to_char $scplayer {weaponType} WeaponType.Pistol {ammo} 30\nmark_model_as_no_longer_needed {modelId} modelId",
    "01B4": "set_player_control $player1 {state} false",
    "01C3": "while true\n    wait 0\n    get_area_visible store_to interiorId\n    if and\n        is_key_pressed Key_F10\n        interiorId == Outside\n    then\n        while is_key_pressed Key_F10\n            wait 0\n        end\n        request_model #HUSTLER\n        load_all_models_now\n        repeat \n            wait 0\n        until has_model_loaded #HUSTLER\n        get_active_camera_coordinates store_to x y z\n        get_closest_car_node_with_heading x y z store_to nodeX nodeY nodeZ heading\n        clear_area nodeX nodeY nodeZ 3.0 False\n        create_car #HUSTLER nodeX nodeY nodeZ store_to Car\n        set_car_heading Car heading\n        mark_car_as_no_longer_needed Car\n        mark_model_as_no_longer_needed #HUSTLER\n    end\nend",
    "01E4": "const player=0\nint carl, health\nget_player_char player store_to carl\nget_char_health carl store_to health\nprint_with_number 'NUMBER' health 2000 true",
    "01F5": "const player=0\nint carl = get_player_char player\nint health = get_char_health carl\nprint_with_number {key} 'NUMBER' {num} health {duration} 2000 {flag} true",
    "020A": "const LockoutPlayerOnly = 3\nfloat x,y,z, radius=10.0\nint Car\nwhile true\n    wait 100\n    get_active_camera_coordinates store_to x y z\n    if get_random_car_in_sphere_no_save_recursive x y z radius findNext True skipWrecked True store_to Car\n    then lock_car_doors Car lockStatus LockoutPlayerOnly\n    end\nend",
    "0226": "const player=0\nint carl, health\nget_player_char player store_to carl\nget_char_health carl store_to health\nprint_with_number 'NUMBER' health 2000 true",
    "0237": "set_gang_weapons {gangId} GangType.Ballas {weaponType1} WeaponType.RocketLauncher {weaponType2} WeaponType.Extinguisher {weaponType3} WeaponType.Flamethrower",
    "023C": "load_special_character {slotId} 1 {modelName} 'SMOKE'\nload_all_models_now\nset_player_model $player1 {modelId} #SPECIAL01\nunload_special_character {slotId} 1",
    "0247": "while true\n    wait 0\n    get_area_visible store_to interiorId\n    if and\n        is_key_pressed Key_F10\n        interiorId == Outside\n    then\n        while is_key_pressed Key_F10\n            wait 0\n        end\n        request_model #HUSTLER\n        load_all_models_now\n        repeat \n            wait 0\n        until has_model_loaded #HUSTLER\n        get_active_camera_coordinates store_to x y z\n        get_closest_car_node_with_heading x y z store_to nodeX nodeY nodeZ heading\n        clear_area nodeX nodeY nodeZ 3.0 False\n        create_car #HUSTLER nodeX nodeY nodeZ store_to Car\n        set_car_heading Car heading\n        mark_car_as_no_longer_needed Car\n        mark_model_as_no_longer_needed #HUSTLER\n    end\nend",
    "0248": "request_model {modelId} #SWAT\n\nwhile not has_model_loaded {modelId} #SWAT\n    wait {time} 0 // single render frame\nend\n\nint guy = create_char {type} PedType.CivMale {modelId} #SWAT {xyz} 2500.0 -1660.0 -100.0\n\nmark_model_as_no_longer_needed {modelId} #SWAT",
    "0249": "while true\n    wait 0\n    get_area_visible store_to interiorId\n    if and\n        is_key_pressed Key_F10\n        interiorId == Outside\n    then\n        while is_key_pressed Key_F10\n            wait 0\n        end\n        request_model #HUSTLER\n        load_all_models_now\n        repeat \n            wait 0\n        until has_model_loaded #HUSTLER\n        get_active_camera_coordinates store_to x y z\n        get_closest_car_node_with_heading x y z store_to nodeX nodeY nodeZ heading\n        clear_area nodeX nodeY nodeZ 3.0 False\n        create_car #HUSTLER nodeX nodeY nodeZ store_to Car\n        set_car_heading Car heading\n        mark_car_as_no_longer_needed Car\n        mark_model_as_no_longer_needed #HUSTLER\n    end\nend",
    "024F": "while true\n    wait {time} 0\n    \n    float x, y, z\n    x, y, z = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 1.0 2.0\n    \n    int coronaType = TimerA / 3000\n    coronaType %= 10\n    print_formatted_now {format} \"Corona type: %d\" {time} 100 {args} coronaType\n\n    draw_corona {pos} x y z {size} 0.5 {coronaType} coronaType {flareType} FlareType.Sun {rgb} 255 128 64\nend",
    "0256": "if\n    is_player_playing $player1\nthen\n    print_string_now {text} \"Not wasted or busted\" {time} 1000\nend",
    "029B": "int modelId = 910\nrequest_model {modelId} modelId\nload_all_models_now\nint obj = create_object_no_offset {modelId} modelId {pos} 2490.0 -1666.0 14.0\nmark_model_as_no_longer_needed {modelId} modelId",
    "0321": "float x,y,z, radius=15.0\nint Char\nwhile true\n    wait 2000\n    get_active_camera_coordinates store_to x y z\n    if get_random_char_in_sphere_no_save_recursive x y z radius findNext True skipDead True store_to handle Char\n    then explode_char_head Char\n    end\nend",
    "034E": "float pos[3]\n...pos = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 5.0 0.0\n\nrequest_model {modelId} #HEALTH\nload_all_models_now\nint obj = create_object {modelId} #HEALTH {pos} ...pos\nmark_model_as_no_longer_needed {modelId} #HEALTH\n\nwhile true\n    wait {time} 0\n    \n    ...pos = get_char_coordinates $scplayer\n    if\n        slide_object obj {pos} ...pos {speed} 0.02 0.02 0.02 {collisionCheck} true\n    then\n        print_string {text} \"~r~Stopped\" {time} 100\n    else\n        print_string {text} \"~g~Sliding...\" {time} 100\n    end\nend",
    "035F": "add_armour_to_char $scplayer {amount} 50",
    "038B": "request_model {modelId} #SWAT\n\nload_all_models_now\n\nint guy = create_char {type} PedType.CivMale {modelId} #SWAT {xyz} 2500.0 -1660.0 -100.0\n\nmark_model_as_no_longer_needed {modelId} #SWAT",
    "0395": "while true\n    wait 0\n    get_area_visible store_to interiorId\n    if and\n        is_key_pressed Key_F10\n        interiorId == Outside\n    then\n        while is_key_pressed Key_F10\n            wait 0\n        end\n        request_model #HUSTLER\n        load_all_models_now\n        repeat \n            wait 0\n        until has_model_loaded #HUSTLER\n        get_active_camera_coordinates store_to x y z\n        get_closest_car_node_with_heading x y z store_to nodeX nodeY nodeZ heading\n        clear_area nodeX nodeY nodeZ 3.0 False\n        create_car #HUSTLER nodeX nodeY nodeZ store_to Car\n        set_car_heading Car heading\n        mark_car_as_no_longer_needed Car\n        mark_model_as_no_longer_needed #HUSTLER\n    end\nend",
    "03A1": "while true\n    wait 0\n\n    float x, y, z\n    x, y, z = get_char_coordinates $scplayer\n\n    draw_sphere {pos} x y z {diameter} 1.0\nend",
    "03C0": "Car myCar = store_car_char_is_in_no_save $scplayer",
    "03C4": "const screenCounter = $sw4_health_display // global variable safe to use, unless \"Ghetto Drive By\" mission is in progress\n\nset_onscreen_counter_flash_when_first_displayed {var_counter} screenCounter {state} true\n\ndisplay_onscreen_counter_with_string {var_counter} screenCounter {display} CounterDisplay.Bar {text} 'DEAD' // WASTED\nscreenCounter = 10 // start with 10%\n\n// animate the bar\nwhile screenCounter < 100\n    screenCounter += 1\n    wait 100 \nend\n\n// display for one more second\nwait 1000\n\n// cleanup\nclear_onscreen_counter {var_counter} screenCounter",
    "03CF": "load_mission_audio {slotId} 1 {audioId} 20600\nwhile not has_mission_audio_loaded {slotId} 1\n    wait 0\nend\n\nplay_mission_audio {slot_id} 1\nwait 2000\n\nclear_mission_audio {slotId} 1",
    "03D3": "while true\n    wait 0\n\n    int interiorId = get_area_visible \n    if and\n        is_key_pressed {keyCode} KeyCode.F8\n        interiorId == 0 // outside\n    then\n        // wait for key release\n        while is_key_pressed {keyCode} KeyCode.F8\n            wait 0\n        end\n        \n        float pos[3]\n        pos[0], pos[1], pos[2] = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 5.0 0.0\n\n        \n        float dir\n        pos[0], pos[1], pos[2], dir = get_closest_car_node_with_heading {pos} pos[0], pos[1], pos[2] // find road\n        \n        clear_area {pos} pos[0] pos[1] pos[2] {radius} 3.0 {clearParticles} false\n        \n        request_model #HUSTLER\n        load_all_models_now\n        int carHandle = create_car {modelId} #HUSTLER {pos} pos[0] pos[1] pos[2]\n        set_car_heading carHandle {heading} dir\n        mark_car_as_no_longer_needed carHandle // will despawn on its own\n    end\nend",
    "03D9": "if\n    not has_save_game_finished\nthen\n    debug_on\n    trace \"Save menu opening\"\nend",
    "03EE": "while true\n    wait {time} 0\n\n    if\n        not can_player_start_mission $player1\n    then\n        add_one_off_sound {pos} 0.0 0.0 0.0 {sound_id} ScriptSound.SoundRaceGo\n    end\nend",
    "0432": "int passenger = get_char_in_car_passenger_seat carHandle {seat} SeatId.FrontRight\nif\n    passenger <> -1\nthen\n    ...\nend",
    "0449": "while true\n    wait 0\n\n    if\n        is_char_sitting_in_any_car $scplayer\n    then\n        print_formatted_now {format} \"Player in vehicle!\" {time} 100\n    end\nend",
    "04A3": "<%= input1 %> == <%= input2 %>",
    "04A4": "<%= input1 %> == <%= input2 %>",
    "04AE": "<%= input1 %> = <%= input2 %>",
    "04AF": "<%= input1 %> = <%= input2 %>",
    "04B0": "<%= input1 %> > <%= input2 %>",
    "04B1": "<%= input1 %> > <%= input2 %>",
    "04B2": "<%= input1 %> > <%= input2 %>",
    "04B3": "<%= input1 %> > <%= input2 %>",
    "04B4": "<%= input1 %> >= <%= input2 %>",
    "04B5": "<%= input1 %> >= <%= input2 %>",
    "04B6": "<%= input1 %> >= <%= input2 %>",
    "04B7": "<%= input1 %> >= <%= input2 %>",
    "04D5": "while true\n    wait {time} 0\n    \n    float x, y, z\n    x, y, z = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 2.0 2.0\n    \n    int coronaType = TimerA / 3000\n    coronaType %= 10\n    print_formatted_now {format} \"Corona type: %d\" {time} 100 {args} coronaType\n\n    draw_weaponshop_corona {pos} x y z {size} 0.5 {coronaType} coronaType {flareType} FlareType.Sun {rgb} 255 128 64\nend",
    "05A9": "<%= input1 %> = <%= input2 %>",
    "05AA": "<%= input1 %> = <%= input2 %>",
    "05AD": "<%= input1 %> == <%= input2 %>",
    "05AE": "<%= input1 %> == <%= input2 %>",
    "0605": "request_animation \"SUNBATHE\" // not needed for \"PED\"!\nload_all_models_now\n        \ntask_play_anim {handle} $scplayer {animationName} \"ParkSit_W_idleA\" {animationFile} \"SUNBATHE\" {blendSpeed} 0.5 {loop} true {lockX} false {lockY} false {keepLastFrame} false {time} 10000\n        \nremove_animation {animationFile} \"SUNBATHE\" // not allowed for \"PED\"!",
    "062A": "set_float_stat {id} StatId.Fat {value} 1000.0",
    "064C": "int effect = create_fx_system {name} \"prt_spark_2\" {pos} 2488.0 -1660.0 13.0 {ignoreBoundingChecks} true\nplay_fx_system effect",
    "066A": "int effect = create_fx_system_on_char_with_direction {name} \"cement\" {char} $scplayer {offset} 0.0 0.5 1.0 {direction} 0.0 0.5 0.5 {ignoreBoundingChecks} true\nplay_fx_system effect",
    "068D": "float x,y,z, radius=15.0\nint Char\nwhile true\n    wait 2000\n    get_active_camera_coordinates store_to x y z\n    if get_random_char_in_sphere_no_save_recursive x y z radius findNext True skipDead True store_to handle Char\n    then explode_char_head Char\n    end\nend",
    "06D1": "<%= input1 %> = <%= input2 %>",
    "06D2": "<%= input1 %> = <%= input2 %>",
    "06D8": "if\n    test_cheat \"train\"\nthen\n    float pos[3]\n    pos[0], pos[1], pos[2] = get_char_coordinates $scplayer\n    \n    warp_char_from_car_to_coord $scplayer {pos} pos[0] pos[1] pos[2] // remove player from car if in any\n    delete_mission_trains\n\n    request_model #TRAM\n    request_model #FREIGHT // freight train locomotive\n    request_model #STREAK // passenger train locomotive\n    request_model #FREIFLAT // freight flat railroad car\n    request_model #FREIBOX // freight box railroad car\n    request_model #STREAKC // passenger railroad car\n    load_all_models_now // force load now\n    \n    int trainType = generate_random_int_in_range {min} 0 {max} 16\n    \n    int trainHandle = create_mission_train {type} trainType {pos} pos[0] pos[1] pos[2] {direction} true\n                    \n    mark_model_as_no_longer_needed #TRAM\n    mark_model_as_no_longer_needed #FREIGHT\n    mark_model_as_no_longer_needed #STREAK\n    mark_model_as_no_longer_needed #FREIFLAT\n    mark_model_as_no_longer_needed #FREIBOX\n    mark_model_as_no_longer_needed #STREAKC\n    \n    warp_char_into_car $scplayer {vehicle} trainHandle\n    point_camera_at_car {vehicle} trainHandle {mode} CameraMode.CamOnAString {switchStyle} SwitchType.JumpCut\n    restore_camera\n    print_help_formatted {text} \"Train type: %d\" {args} trainType\nend",
    "06E7": "int modelIdx = #WHEEL_OR1\n\nrequest_vehicle_mod {modelId} modelIdx\nif\n\tnot has_model_loaded {modelId} modelIdx\nthen\n\tload_all_models_now\nend \n\nint modHandle = add_vehicle_mod carHandle {modelId} modelIdx\n\nmark_vehicle_mod_as_no_longer_needed {modelId} modelIdx",
    "070A": "int modelId = #HEALTH\nrequest_model {modelId} modelId\nload_all_models_now\nint obj = create_object {modelId} modelId {pos} 0.0 0.0 0.0\nmark_model_as_no_longer_needed {modelId} modelId\n\ntask_pick_up_object {char} $scplayer {object} obj {offset} 0.0 0.1 0.0 {bone} PedBoneId.Head {orientation} HoldOrientation.Bone {animationName} \"NULL\" {animationFile} \"NULL\" {time} -1",
    "077E": "while true\n    wait 0\n    get_area_visible store_to interiorId\n    if and\n        is_key_pressed Key_F10\n        interiorId == Outside\n    then\n        while is_key_pressed Key_F10\n            wait 0\n        end\n        request_model #HUSTLER\n        load_all_models_now\n        repeat \n            wait 0\n        until has_model_loaded #HUSTLER\n        get_active_camera_coordinates store_to x y z\n        get_closest_car_node_with_heading x y z store_to nodeX nodeY nodeZ heading\n        clear_area nodeX nodeY nodeZ 3.0 False\n        create_car #HUSTLER nodeX nodeY nodeZ store_to Car\n        set_car_heading Car heading\n        mark_car_as_no_longer_needed Car\n        mark_model_as_no_longer_needed #HUSTLER\n    end\nend",
    "07D6": "<%= input1 %> == <%= input2 %>",
    "07D7": "<%= input1 %> == <%= input2 %>",
    "0804": "set_char_coordinates $scplayer {pos} 2503.3533 -1686.2238 12.5\n\nrequest_animation \"CRIB\" // not needed for \"PED\"!\nload_all_models_now\n\ntask_char_slide_to_coord_and_play_anim {handle} $scplayer {pos} 2515.0 -1689.0 13.6 {heading} 50.0 {radius} 0.5 {animationName} \"PED_Console_Loop\" {animationFile} \"CRIB\" {blendSpeed} 1.0 {loop} true {lockX} false {lockY} false {keepLastFrame} false {time} 8000\n\nremove_animation {animationFile} \"CRIB\" // not allowed for \"PED\"!",
    "0806": "int prevKillCount = get_total_number_of_peds_killed_by_player $player1\nwhile true\n    wait 250\n    \n    int killCount = get_total_number_of_peds_killed_by_player $player1\n    killCount -= prevKillCount\n    \n    if\n        killCount > 0\n    then\n        print_formatted_now {format} \"Another %d bites the dust!\" {time} 3000 {args} killCount\n        add_one_off_sound {pos} 0.0 0.0 0.0 {soundId} ScriptSound.SoundCheckpointRed\n\n        prevKillCount += killCount\n    end\nend",
    "0812": "request_animation \"SWAT\" // not needed for \"PED\"!\nload_all_models_now\n\ntask_play_anim_non_interruptable {handle} $scplayer {animationName} \"swt_lkt\" {animationFile} \"SWAT\" {blendSpeed} 3.0 {loop} true {lockX} true {lockY} true {keepLastFrame} false {time} 60000\n\nremove_animation {animationFile} \"SWAT\" // not allowed for \"PED\"!\n\nalter_wanted_level $player1 {wantedLevel} 5 // interruptions",
    "0829": "request_animation \"BASEBALL\" // not needed for \"PED\"!\nload_all_models_now\n\ntask_die_named_anim {handle} $scplayer {animationName} \"Bat_Hit_3\" {animationFile} \"BASEBALL\" {blendSpeed} 3.0 {time} -1\n\nremove_animation {animationFile} \"BASEBALL\" // not allowed for \"PED\"!",
    "083F": "debug_on // enable trace command\nwhile true\n    wait 0\n    \n    int carHandle = get_car_char_is_using $scplayer\n    if\n        carHandle <> -1\n    then\n        float up = get_car_upright_value carHandle\n        trace \"Up: %0.2f\" up\n    end    \nend",
    "0871": "0871: switch_start $model_id num_cases 3 has_default_case true @default_label #NRG500 @case_nrg #FCR900 @case_fcr #BF400 @case_bf400 -1 @end_switch -1 @end_switch -1 @end_switch -1 @end_switch\n0871: switch_start $girlfriend num_cases 4 has_default_case false @end_switch 1 @case_michelle 2 @case_helena 3 @case_barbara 4 @case_katie -1 @end_switch -1 @end_switch -1 @end_switch",
    "0872": "0872: switch_continued #PETRO @IMPEXPM_12617 #FCR900 @IMPEXPM_12743 #NRG500 @IMPEXPM_12512 #FELTZER @IMPEXPM_12449 #REMINGTN @IMPEXPM_12470 #SLAMVAN @IMPEXPM_12659 #BLADE @IMPEXPM_12932 #VORTEX @IMPEXPM_13058 #BULLET @IMPEXPM_13079 \n0872: switch_continued #WINDSOR @IMPEXPM_12533 #JESTER @IMPEXPM_12260 #BANDITO @IMPEXPM_12785 #DUNERIDE @IMPEXPM_13037 #HUNTLEY @IMPEXPM_12890 #STAFFORD @IMPEXPM_12701 #EUROS @IMPEXPM_12764 #CLUB @IMPEXPM_12239 -1 @IMPEXPM_13121",
    "087B": "set_current_directory {path} 0 // restore default, prevents crash if changed by other scripts (prior to CLEO5)\ngive_player_clothes_outside_shop 0 {textureName} \"tash\" {modelName} \"cornrows\" {bodyPart} BodyPart.Head\nbuild_player_model 0\nset_player_model 0 {modelId} 0",
    "0883": "int effect = create_fx_system_on_char_with_direction {name} \"petrolcan\" {char} $scplayer {offset} 0.0 0.0 0.0 {direction} 0.0 0.0 1.0 {ignoreBoundingChecks} true\nattach_fx_system_to_char_bone effect {handle} $scplayer {pedBone} PedBone.RightHand\nplay_fx_system effect",
    "08C8": "int hash_key\nhash_key = get_hash_key {text} \"hattiger\"\nadd_price_modifier {itemId} hash_key {price} 33\nhash_key = get_hash_key {text} \"afro\"\nadd_price_modifier {itemId} hash_key {price} 44\nhash_key = get_hash_key {text} \"4RIP\"\nadd_price_modifier {itemId} hash_key {price} 55\n\nadd_price_modifier {itemId} #exh_lr_sv1 {price} 888\nadd_price_modifier {itemId} #clucklow {price} 22          \nadd_price_modifier {itemId} 48 {price} 66 // WeaponType.Armour",
    "08D4": "add_text_label {dynamicKey} 'MENUTIT' {text} \"Title\"\nadd_text_label {dynamicKey} 'MENU01' {text} \"Option 1\"\nadd_text_label {dynamicKey} 'MENU02' {text} \"Option 2\"\nadd_text_label {dynamicKey} 'MENU03' {text} \"Option 3\"\n\nint menuHandle = create_menu {header} 'MENUTIT' {xy} 32.0 150.0 {width} 180.0 {numColumns} 1 {interactive} true {background} true {alignment} Align.Center\nset_menu_column menuHandle {column} 0 {title} 'DUMMY' {rows} 'MENU01' 'MENU02' 'MENU03' 'DUMMY' 'DUMMY' 'DUMMY' 'DUMMY' 'DUMMY' 'DUMMY' 'DUMMY' 'DUMMY' 'DUMMY'\n\n// wait for user choice\nint choice\nrepeat\n    wait {time} 0\n    choice = get_menu_item_accepted menuHandle\nuntil choice >= 0\n\ndelete_menu menuHandle\n\nprint_help_formatted {text} \"Selected index: %d\" {args} choice",
    "08F9": "<%= input1 %> == <%= input2 %>",
    "08FA": "<%= input1 %> == <%= input2 %>",
    "0904": "use_text_commands {state} true\nwhile true\n    wait {time} 0\n    \n    int r, g, b, a\n    r, g, b, a = get_hud_colour {color} HudColors.BlueLight\n    \n    draw_rect {pos} 10.0 10.0 {size} 200.0 200.0 {color} r g b a\nend",
    "092E": "while true\n    wait 0\n    \n    float x, y, z\n    x, y, z = get_active_camera_coordinates\n\n    float waterHeight = get_water_height_at_coords {pos} x y {waves} true\n\n    print_formatted_now {format} \"Water: %0.2fm\" {time} 100 {args} waterHeight\nend",
    "095C": "while true\n    wait {time} 500\n    \n    float x, y, z\n    x, y, z = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 0.0 0.8\n    \n    add_smoke_particle {pos} x y z {velocity} 0.0 0.0 1.0 {rgb} 1.0 0.5 0.25 {alpha} 1.0 {size} 0.1 {lastFactor} 0.5\nend",
    "0975": "const modelId = #FIRELA\nrequest_model modelId\nload_all_models_now\nCar c = create_car modelId 0 0 0\nmark_model_as_no_longer_needed modelId\nif is_emergency_services_vehicle c\nthen\n    print_formatted \"Car %d is an emergency vehicle\" 5000 modelId\nelse\n    print_formatted \"Car %d is not an emergency vehicle\" 5000 modelId\nend",
    "098B": "<%= output1 %> = <%= input1 %> + <%= input2 %>",
    "098C": "<%= output1 %> = <%= input1 %> + <%= input2 %>",
    "09A0": "int modelId = #BONUS\nrequest_model {modelId} modelId\nload_all_models_now\nint obj = create_object {modelId} modelId {pos} 0.0 0.0 0.0\nmark_model_as_no_longer_needed {modelId} modelId\n\ntask_pick_up_object {char} $scplayer {object} obj {offset} 0.0 0.0 0.0 {bone} PedBoneId.HandR {orientation} HoldOrientation.PedHeading {animationName} \"NULL\" {animationFile} \"NULL\" {time} -1\n\nmodelId = #BONUS\nrequest_model {modelId} modelId\nload_all_models_now\nobj = create_object {modelId} modelId {pos} 0.0 0.0 0.0\nmark_model_as_no_longer_needed {modelId} modelId\n\ntask_pick_up_second_object {char} $scplayer {object} obj {offset} 0.0 0.0 0.0 {bone} PedBoneId.HandL {orientation} HoldOrientation.Bone {animationName} \"NULL\" {animationFile} \"NULL\" {time} -1",
    "09C0": "const player=0, posOffset=120.0, negOffset=-120.0, NumLock = 144\nint Char, Car, Blip\nfloat x,y,z,x2,y2,z2\n\nget_player_char Player store_to Char   \nwhile true\n    wait 0\n    if \n        is_key_just_pressed NumLock\n    then  \n        get_offset_from_char_in_world_coords Char posOffset posOffset posOffset store_to x y z\n        get_offset_from_char_in_world_coords Char negOffset negOffset negOffset store_to x2 y2 z2    \n        get_random_car_of_type_in_angled_area_no_save x2 y2 x y 20.0 #TAXI store_to Car\n        if Car <> -1           \n        then add_blip_for_car Car store_to Blip\n        end\n    end\nend",
    "09C7": "request_model {modelId} 100\nload_all_models_now\nset_player_model $player1 {modelId} 100\nmark_model_as_no_longer_needed {modelId} 100",
    "09D5": "int selectedLine = set_char_say_context_important $scplayer {phrase} SpeechId.PainCjHighFall {overrideSilence} true {ignoreMute} false {frontEnd} false",
    "09E5": "while true\n    wait {time} 0\n\n    float x, y, z\n    x, y, z = get_offset_from_char_in_world_coords $scplayer {offset} 0.0 1.0 0.5\n    \n    draw_light_with_range {pos} x y z {rgb} 0 255 64 {radius} 3.0\nend",
    "09E7": "while true\n    wait {time} 0\n    if\n        is_player_control_on $player1\n    then\n        print_string_now {text} \"player can move\" {time} 1\n    end\nend",
    "0A08": "int width = get_string_width_with_number 'BJ_0' number 42  // ~1~",
    "0A1A": "request_animation \"GANGS\" // not needed for \"PED\"!\nload_all_models_now\n\ntask_play_anim_secondary {handle} $scplayer {animationName} \"PRTIAL_GNGTLKE\" {animationFile} \"GANGS\" {blendSpeed} 0.2 {loop} true {lockX} false {lockY} false {keepLastFrame} false {time} -1\n\nremove_animation {animationFile} \"GANGS\" // not allowed for \"PED\""
  },
  "file": {
    "0B02": "move_file <%= input1 %> {to} <%= input2 %>",
    "0B03": "move_directory <%= input1 %> {to} <%= input2 %>",
    "0B04": "copy_file <%= input1 %> {to} <%= input2 %>",
    "0B05": "copy_directory <%= input1 %> {to} <%= input2 %>",
    "2301": "int f = open_file {filePathName} \"root:\\stream.ini\" {mode} \"rb\" // file must be open in binary mode\nint size = get_file_size f\nint buf = allocate_memory {size} size\n\nread_block_from_file f {size} size {address} buf // read file into allocated buffer\n\ndebug_on\ntrace \"Read: %s\" buf\n\nfree_memory buf",
    "2302": "\nint f = open_file \"root:\\dump.txt\" \"wb\" // create file in game root folder\n\nint buf_start = get_label_pointer @buf_start\nint buf_end = get_label_pointer @buf_end\nint size = buf_end - buf_start\n\nwrite_block_to_file f size buf_start // write content of hex block to file\nclose_file f\n\n\n\n\n:buf_start\nhex\n    \"hello world\" 00\nend\n:buf_end\n",
    "2303": "debug_on // enable trace command\nint buf = allocate_memory size 260 \n\nbuf = resolve_filepath \"root:\" // game root directory\ntrace \"Game installed in %s\" 0@\n\nbuf = resolve_filepath \"root:\\data\\ped.dat\" // get path to ped.dat\ntrace buf\n\nbuf = resolve_filepath \"user:\" // game saves location\ntrace \"User data location:~w~ %s\" buf\n\nbuf = resolve_filepath \".\" // this script's source file directory (not affected by 0A99)\ntrace \"This script dir:~w~ %s\" buf\n\nbuf = resolve_filepath \"cleo:\" // virtual path: CLEO directory\ntrace \"CLEO dir:~w~ %s\" buf\n\nbuf = resolve_filepath \"modules:\" // virtual path: CLEO modules directory\ntrace \"CLEO modules dir:~w~ %s\" buf\n\nbuf = resolve_filepath \"\" // relative path\ntrace \"Script's working directory is:~w~ %s\" buf\n\nbuf = resolve_filepath \"file.txt\" // relative path \ntrace buf\n\nset_current_directory 1 // user data\n\nbuf = resolve_filepath \"\" // relative path\ntrace \"Script's changed working directory is:~w~ %s\" buf\n\nbuf = resolve_filepath \"file.txt\" // path relative to location set with 0A99\ntrace buf\n\nfree_memory buf",
    "2304": "debug_on // enable trace command\n\nLongString name = get_script_filename {address} -1 {fullPath} false\ntrace \"This script file:~w~ %s\" name\n \nint script = get_script_struct_named {scriptName} \"main\"\nint str = allocate_memory {size} 260\nstr = get_script_filename {address} script {fullPath} true\ntrace \"Other script:~w~ %s\" str\nfree_memory str",
    "2305": "int year, month, day, hour, minute, second, milisecond\nyear, month, day, hour, minute, second, milisecond = get_file_write_time {fileName} \"root:\\cleo.asi\"\n\ndebug_on\ntrace \"CLEO.asi date is %04d-%02d-%02d %02d:%02d:%02d.%03d\" year month day hour minute second milisecond"
  },
  "imgui": {
    "2218": "if\n    imgui_button {buttonName} \"Press me!\" {width} 0.0 {height} 0.0\nthen\n    print_help_formatted {text} \"Button was pressed!\"\nend"
  },
  "input": {
    "2080": "while true\n    wait {time} 0 // other than 0 will cause is_key_just_pressed to miss some key presses\n\n    if\n        is_key_just_pressed {keyCode} KeyCode.A\n    then\n        print_help_string {text} \"Key pressed!\"\n    end\nend",
    "2081": "while true\n    wait {time} 0\n    \n    int key\n    if\n        key = get_key_pressed_in_range {minKeyCode} KeyCode.Num0 {maxKeyCode} KeyCode.Num9\n    then\n        print_help_formatted {text} \"Key press: %c\" {args} key // many keycodes are same as their ASCII representation\n    \n        // wait for keys release\n        repeat\n            wait {time} 0\n        until not key = get_key_pressed_in_range {minKeyCode} KeyCode.Num0 {maxKeyCode} KeyCode.Num9\n    end \nend",
    "2082": "int buffer = allocate_memory {size} 256\n\nwhile true\n    wait {time} 0 // other than 0 will cause get_key_just_pressed_in_range to miss some key presses\n    \n    print_formatted_now {format} \"Input text:~n~%s_\" {time} 100 {args} buffer\n        \n    if\n        int key = get_key_just_pressed_in_range {minKeyCode} KeyCode.Space {maxKeyCode} KeyCode.Z\n    then\n        string_format {result} buffer {format} \"%s%c\" {args} buffer key // append character\n    end\nend",
    "2083": "emulate_key_press {keyCode} KeyCode.W",
    "2084": "emulate_key_press {keyCode} KeyCode.W\nwait {time} 3000\nemulate_key_release {keyCode} KeyCode.W",
    "2085": "int key = get_controller_key {action} ControllerAction.PedJump {altKey} ControllerAltKey.Primary",
    "2086": "debug_on // enable trace command\n\nwhile true\n    wait {time} 0 // other than 0 will miss some key presses\n    \n    if\n        int key = get_key_just_pressed_in_range {minKeyCode} KeyCode.Min {maxKeyCode} KeyCode.Max\n    then\n        longString name = \"???\"\n        name = get_key_name {keyCode} key\n        trace \"Key press: 0x%02X  %s\" key name\n    end\nend"
  },
  "math": {
    "2700": "int val = 0x100\nif\n    is_bit_set {number} val {bitIndex} 8 // 0-based indexing\nthen\n    ...\nend",
    "2705": "int bikeModel = pick_random_int {values} 581 462 521 463",
    "2706": "float heading = pick_random_float {values} 0.0 90.0 -90.0 180.0",
    "2707": "LongString greeting = pick_random_text {values} \"Hello!\" \"Hi there!\" \"Welcome!\"",
    "2708": "if\n    random_chance {percent} 33.333\nthen\n    print_help_string {text} \"1/3 chance\"\nend"
  },
  "memory": {
    "2400": "get_var_pointer 0@ {store_to} 5@\nget_var_pointer 1@ {store_to} 6@\n\ncopy_memory {src} 5@ {dest} 6@ {size} 2 // replace two bytes in 1@",
    "2401": "int ptr = get_this_script_struct\n\nint baseIp = read_memory_with_offset ptr {offset} 0x10 {size} 4 // get CRunningScript::BaseIP\nshortString name = read_memory_with_offset ptr {offset} 0x08 {size} 4 // get CRunningScript::Name",
    "2402": "get_vehicle_pointer 0@ {result} 5@\nwrite_memory_with_offset {address} 5@ {offset} 0x434 {size} 1 {value} 126 // set CVehicle::m_nPrimaryColor",
    "2404": "stream_custom_script \".\\other_script.s\"\nget_script_struct_just_created 11@\n\n// wait for script to finish\nwhile is_script_running 11@\n    wait 0\nend"
  },
  "text": {
    "2605": "while true\n   wait 0 // draw each frame\n   use_text_commands {state} true\n   display_text_formatted {offsetLeft} 50.0 {offsetTop} 100.0 {format} \"Simple text\"\n   display_text_formatted {offsetLeft} 50.0 {offsetTop} 200.0 {format} \"Timer: %d\" {args} TIMERA\nend",
    "2609": "int value = 250\nadd_text_label_formatted {dynamicKey} 'PRICE' {format} 'Price $%d' {args} value"
  }
}
